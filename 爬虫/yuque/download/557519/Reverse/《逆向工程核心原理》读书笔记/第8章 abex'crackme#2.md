本章分析一个非常简单的crackme文件，帮助大家继续熟悉调试器与反汇编代码。先简单介绍**Visual Basic**的文件结构及分析方法。

本章分析第二个crackme文件abex'crackme#2，它使用Visual Basic语言编写，你会感受到与使用Visual C++或Assembly编写的文件相比具有不同的形态。

提示------------------------------------------------------------------------------------------------------------------

讲解中出现的内存（栈）地址随用户PC环境的不同而变化。希望各位调试时注意这一点。你现在感到调试很难是正常的，投入大量时间和精力后，就会逐渐熟悉起来。

-----------------------------------------------------------------------------------------------------------------------

# 8.1运行abex'crackme#2
运行之后才能了解它是什么样的程序，如图8-1所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581075284696-54e35838-b217-4be0-b267-28571dee1a8c.png)

图8-1 运行画面

这个程序具有典型的crackme形态，要求我们找出程序的序列号。从单独输入Name来看，生成Serial时才会用到Name字符串（依据经验推测）。输入合适的Name与Serial，按Check按钮，如图8-2所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581075384237-10728d07-667e-43c5-8d31-943751dcb325.png)

图8-2“Wrong serial!”消息框

弹出“Wrong serial!”消息框，即使多次尝试其他值也依然是这个结果。下面通过调试仔细分析其代码。

提示------------------------------------------------------------------------------------------------------------------

若上述示例文件（abexcm2-voiees.exex）无法运行，请先把附带的MSVBVM60.dll文件复制到示例文件相同路径下再操作。

-----------------------------------------------------------------------------------------------------------------------

# 8.2Visual Basic文件的特征
要调试的abex's crackme#2文件由Visual Basic编写而成。调试前最好先了解Visual Basic文件的特征。

## 8.2.1VB专用引擎
**<font style="color:#F5222D;">VB文件使用名为MSVBVM60.dll</font>**（Microsoft Visual Basic Virtual Machine6.0)**<font style="color:#F5222D;">的VB专用引擎</font>**（也称为The Thunder Runtime Engine)。

**举个使用VB引擎的例子，显示消息框时，VB代码中要调用MsgBox()函数。其实，VB编辑器真正调用的是MSVBVM60.d11里的rtcMsgBox）函数，在该函数内部通过调用user32.dll里的MessageBoxW****()****函数（Win32API)来工作（也可以在VB代码中直接调用user32.dll里的MessageBoxW****()****)。**

## 8.2.2本地代码和伪代码
根据使用的编译选项的不同，VB文件可以编译为**<font style="color:#F5222D;">本地代码（Ncode）</font>**与**<font style="color:#F5222D;">伪代码（Pcode）</font>**。**<font style="color:#F5222D;">本地代码一般使用易于调试器解析的IA-32指令；而伪代码是一种解释器（Interpreter)语言，它使用由VB引擎实现虚拟机并可自解析的指令（字节码）。</font>**因此，若想准确解析VB的伪代码，就需要分析VB引擎并实现模拟器。

提示------------------------------------------------------------------------------------------------------------------ 

伪代码具有与Java（Java虚拟机）、Python（Python专用引擎）类似的形态结构。**使用伪代码的好处是非常方便代码移植**（编写/发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在指定平台上运行）。

-----------------------------------------------------------------------------------------------------------------------

## 8.2.3事件处理程序
VB主要用来编写GUI程序，IDE用户界面本身也最适合于GUI编程。**由于VB程序采用Windows操作系统的事件驱动方式工作，所以在main()或WinMain****()****中并不存在用户代码（希望调试的代码），用户代码存在于各个事件处理程序（event handler)之中。**

   就上述abex'crackme#2而言，**用户代码在点击Check按钮时触发的事件处理程序内**。

## 8.2.4未文档化的结构体
VB中使用的各种信息（Dialog、Control、Form、Module、Function等）以<font style="color:#F5222D;">结构体</font>形式保存在文件内部。由于微软未正式公开这种结构体信息，所以调试VB文件会难一些。

# 8.3开始调试
运行OllyDbg，查看abex'crackme#2文件的反汇编代码，如图8-3所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581129227224-6ff698e6-78d2-4a47-a70d-a9b2bd8f72b7.png)

图8-3EP

执行程序后，在EP代码中首先要做的是调用VB引擎的主函数（ThunRTMain()）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581129411274-a651ffbc-5e7a-438c-91c1-6694d0f4d503.png)

EP的地址为401238。401238地址处的PUSH 401E14命令用来把RT MainStruct结构体的地址（401E14)压入栈。然后40123D地址处的CALL 00401232命令调用401232地址处的JMP DWORD PTR DS:[4010A0]指令。该JMP指令会跳转至VB引擎的主函数ThunRTMain()（前面压入栈的401E14的值作为ThunRTMain()的参数）。

以上3行代码是VB文件的全部启动代码。虽然非常简单，但有3个方面需要各位留意。

## 8.3.1间接调用
40123D地址处的CALL 401232命令用于调用ThunRTMain()函数，这里使用了较为特别的技法。不是直接转到MSVBVM60.dll里的ThunRTMain()函数，而是通过中间401232地址处的JMP命令跳转。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581129664318-6afa6b89-512b-429a-8ac5-90d5b70a5695.png)

这就是VC++、VB编译器中常用的**<font style="color:#F5222D;">间接调用法</font>**（Indirect Call）。

提示------------------------------------------------------------------------------------------------------------------

4010A0地址是IAT（Import Address Table，导入地址表）区域，包含着MSVBVM60，ThunRTMain()函数的实际地址。第13章将详细讲解IAT。

-----------------------------------------------------------------------------------------------------------------------

## 8.3.2RT_MainStruct结构体
要注意的是ThunRTMain()函数的参数RT_MainStruct结构体。这里，RT_MainStruct结构体存在于401E14地址处，如图8-4所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581130026428-6f76c4e4-d464-42a9-b26e-08d298503f8e.png)

图8-4 RT_MainStruct

微软未公开RT_MainStruct，但是有国外的逆向分析高手已经完成了对RT_MainStruct结构体的分析，并公布在网络上。

RT_MainStruct结构体的成员是其他结构体的地址。也就是说，VB引擎通过参数传递过来的RT_MainStruct结构体获取程序运行需要的所有信息。

此处省略对RT_MainStruct结构体的详细说明。

8.3.3 ThunRTMain()函数

前面提到了ThunRTMain()函数，下面了解一下。

图8-5显示了ThunRTMain()代码的开始部分，可以看到内存地址完全不同了。这是MSVBVM60.dll模块的地址区域。换言之，我们分析的不是程序代码，而是VB引擎代码（现在还不需要分析如此庞大的代码）。对VB文件的讲解到此为止，继续回到abex'crackme#2。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581130239181-34a89c59-0059-4d4a-ba24-da6610ddb0ab.png)

图8-5 ThunRTMain()代码开始

总结一下：

EP代码（地址：401238）（PUSH 401E14）->把RT MainStruct结构体的地址（401E14)压入栈->CALL 00401232（地址：40123D）->JMP DWORD PTR DS:[4010A0]->跳转至VB引擎的主函数ThunRTMain()（为MSVBVM60.dll模块的地址区域）（4010A0地址是IAT（Import Address Table，导入地址表）区域，包含着MSVBVM60，ThunRTMain()函数的实际地址。）->（以上代码称之为VB文件的启动代码）->ThunRTMain()函数的参数RT_MainStruct结构体（地址：401E14）（RT_MainStruct结构体的成员是其他结构体的地址。也就是说，VB引擎通过参数传递过来的RT_MainStruct结构体获取程序运行需要的所有信息）

注：前面压入栈的401E14的值作为ThunRTMain()的参数

# 8.4分析 crackme
要“打补丁”的代码到底在哪呢?应该先找到解决问题的线索。以各位现在的水平，分析RT_MainStruct结构体不是件容易的事，要想一个更简单的方法才行。这种思路就是利用图8-2中的错误消息框与字符串。

## 8.4.1检索字符串
使用OllyDbg中的字符串检索功能（选择All referenced text strings)（右键->查找->所有参考文本字符串），显示出图8-6所示的窗口。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581131329151-75aebd56-3c7d-4190-a825-687017e66461.png)

图8-6 All referenced text strings

可以在上面窗口中看到消息框显示的字符串。双击相应字符串（“Wrong serial”），转到其地址处，如图8-7所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581131501303-2ce7b1a1-c144-4236-b5e5-7fb9885a98b4.png)

图8-7 403458地址

消息框的标题（“Wrong serial！”）、内容（“Nope，this serial is wrong!”)，还有实际调用消息框函数的代码（4034A6）都显示出来了。

从编程的观点来看，使用某种算法生成序列号，通过比较用户输入的序列号与字符串，代码分为TRUE（序列号相同）与FALSE（序列号不同）两大部分。换言之，上述代码的前后存在字符串比较代码，且序列号正确时程序代码会调用消息框输出成功消息（序列号正确时调用消息框，这一点可由图8-6中的字符串类比推测出来）。

在图8-7中略微向上拖动滚动条，果然（如前预测）看到了包含条件转移语句的代码（参考图8-8）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581131710734-a18cae6b-246b-4c92-a8ca-c65040041c3c.png)

图8-8条件转移指令

调用403329地址的__vbaVarTstEq()函数，比较（TEST命令）返回值（AX)后，由403332地址的条件转移指令（正指令）决定执行“真”代码还是“假”代码。

上述代码使用的汇编指令说明-----------------------------------------------------------------------------------------

TEST：逻辑比较（Logical Compare)

与bit-wise logical（按位运算）‘AND'一样（仅改变EFLAGS寄存器而不改变操作数的值）若2个操作数中一个为0，则AND运算结果被置为0→ZF=1。

JE：条件转移指令（Jump if equal)

若ZF=1，则跳转。

-----------------------------------------------------------------------------------------------------------------------

## 8.4.2查找字符串地址
图8-8中403329地址处的__vbaVarTstEq()函数为字符串比较函数，其上方的2个PUSH指令为比较函数的参数，即比较的字符串（联想到C语言的strcmp()函数而推测出的）。

调试至403329地址处。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581132078271-22f3ee5c-1e26-4e1c-8497-873e8f601e1d.png)

00403321地址处的SS；[EBP-44]表达的是什么呢?“IA-32基本说明”与“栈帧”中讲过，SS是栈段，EBP是基址指针寄存器。换言之，SS:[EBP-44]指的是栈内地址，它恰好又是函数中声明的局部对象的地址（局部对象存储在栈区）。在此状态下查看栈（这时你需要在程序框中输入：ReverseCore，abcd1234并且按下程序中的check按钮），如图8-9所示（栈地址会随调试环境的不同而改变）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581132677324-0bbb9221-1e5b-4c8e-9f79-97ebabef55cb.png)

图8-9 栈

查看存储在栈中的内存地址（19F1BC、19F1AC），如图8-10所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581133001741-aca3de24-a50d-4004-b248-d497932b34bc.png)

图8-10 栈内存

提示------------------------------------------------------------------------------------------------------------------

OllyDbg中有一个更方便的查找命令，使用时不需要输入地址。在代码窗口或栈窗口中使用鼠标选中指定地址，使用右键菜单中的Follow in dump或Follow in dump→Memory address命令即可。

-----------------------------------------------------------------------------------------------------------------------

与C++的string类一样，VB字符串使用可变长度的字符串类型。所以就像在图8-10看到的一样，直接显示的不是字符串，而是16字节大小的数据（这就是VB中使用的字符串对象）。

不同的值被这样统一起来，仅方框显示的值是不同的，看上去就像内存地址一样（可变长度字符串类型内部持有实际动态分配的字符串缓存地址）。

**在OllyDbg的Dump窗口中选择右键菜单Long-Address with ASCII dump（长型->ASCII数据地址）命令。该命令可以把Dump窗口的查看形式变得与栈窗口一样，特别是针对字符串地址时可以将相应字符串显示出来（若想返回原视图，使用鼠标右键菜单的Hex-Hex/ASCII（16个字节）命令即可）**。

如图8-11所示，EDX（0019F1A8）最终是实际的serial值，EAX（0019F1B8）是用户输入的serial值（请注意VB使用Unicode字符串）。进入字符串所在地址可以看到实际的字符串。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581133598907-d978aabc-1f11-4d31-841f-ef477a53ffdf.png)

图8-11 Long-Address with ASCII dump

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581134248286-be86d5e1-7d87-44e0-888a-c123360ef4e4.png)

（注：读者的ASCII窗口为乱码，应该是中文环境导致（猜的））

提示------------------------------------------------------------------------------------------------------------------

图8-10~图8-12中的Unicode字符串地址是不一样的（读者是一次性调试的，因此地址是相同的）。原因在于它们不是在同一调试过程中截图的，而是经过多次调试重启截取的，所以字符串的地址发生了变化。**<font style="color:#F5222D;">VB默认使用基于Unicode的可变长度字符串对象。可变长度字符串对象会根据需要在内部随时动态分配/释放内存。因此，每次运行时字符串的地址会有所不同。此外，调试时无法一眼看全实际字符串，这也是调试的困难之一。</font>**

-----------------------------------------------------------------------------------------------------------------------

运行Crackme程序，输入Name=“ReverseCore”、Serial=“B6C9DAC9”，会弹出成功的消息框，如图8-13所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581134363978-73a188be-beef-4854-9fe4-46984882bd3c.png)

图8-13“Congratulations!”消息框

消息框表明找到了正确的Serial并破解成功。但Name与Serial之间是什么关系呢?为了测试，向Name中输入另一个值，Serial保持不变，程序显示错误信息。这证明了最初的推测，即程序采用了“以Name字符串为基础随时生成Serial”的算法。

## 8.4.3生成Serial的算法
本节讲述生成Serial字符串的算法。

**查找函数开始部分**

很显然，图8-8中的条件转移代码属于某个函数。该函数可能就是Check按钮的事件处理程序。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581131710734-a18cae6b-246b-4c92-a8ca-c65040041c3c.png)

图8-8条件转移指令

原因在于选择Check按钮后，该函数会被调用执行，且含有用户代码来弹出成功/失败消息框。

最好倒着向上一点点地查找函数开始部分。向上拖动滚动条即可见到图8-14所示的代码。仔细看一下00402ED0地址处的命令。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581134622419-1b435435-8f4e-4970-bb58-5fd720e14e76.png)

上述代码是典型的栈帧代码，开始执行函数就会形成**<font style="color:#F5222D;">栈帧</font>**。由此得知该位置就是函数开始部分，**即Check按钮的事件处理程序。**

汇编指令--------------------------------------------------------------------------------------------------------------

VB文件的函数之间存在着NOP指令（图8-14的402ECC~402ECF地址区）。

NOP:No Operation，不执行任何动作的指令（只消耗CPU时钟）。

-----------------------------------------------------------------------------------------------------------------------

为了准确分析代码，在402ED0处设置断点（F2）后开始调试。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581134838431-c53801ce-06b3-4c81-83dd-2ddfccbfc6b0.png)

图8-14按钮的事件处理程序

## 8.4.4预测代码
如果你有编程或逆向分析经验，就可以预测出生成序列号的方法。若是Win32API程序，则有如下特点。

    - 读取Name字符串（使用GetWindowText、GetDlgltemText等API）。
    - 启动循环，对字符加密（XOR、ADD、SUB等）。

上述文件使用VB引擎函数编写而成，也有类似的原理。若预测正确，从图8-14的事件处理程序起始代码开始调试，查找到读取Name字符串的部分后，紧接着就会出现加密循环。

提示-----------------------------------------------------------------------------------------------------------------

调试前先预测代码的实现，这是个好习惯。若预测有误也没关系，从头开始调试即可。但若是有幸预测正确，则可以节省大量调试时间。

-----------------------------------------------------------------------------------------------------------------------

## 8.4.5读取Name字符串的代码
记住：我们已经在402ED0处设置了断点

在402F98处设置断点，按下F9开始执行程序

在程序框中输入：“ReverseCore”和“abcd1234”如下图：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581147440557-fdc95141-9d57-4cd0-91cb-a8919d679044.png)

点击“check”按钮，程序来到：402ED0地址处，按下F9继续执行：程序来到：402F98地址处。

**<font style="color:#F5222D;">注意-----------------------------------------------------------------------------------------------------------------</font>**

**<font style="color:#F5222D;">若当OD中显示如下图时，在Dump窗口中按下Ctrl+G转到此时的ESP所指向的地址。（千万别再404000处瞎找，读者就是卡在这里非常长时间）</font>**

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581147809223-d730f155-0579-43c0-bd6e-8640c2789f17.png)

**<font style="color:#F5222D;">----------------------------------------------------------------------------------------------------------------------</font>**

我此时的ESP指向：0019F084，来到如图8-15：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581147855011-c9471bd4-c97c-41ec-bb06-f8c906e6d379.png)

图8-15

继续调试：单步步过402F98。

**要查找的是Name字符串，在VB中，字符串使用字符串对象（这与C语言使用char数组不同），如图8-15查看内存，很难认出实际的字符串。因此把OlyDbg的Dump窗口更改为Long-Addresswith ASCII dump视图模式。**

更改视图方式后，就可以直接看到VB字符串对象存储实际字符串的缓存地址了。在该状态下运行到402F98地址处的CALL命令，值存储到字符串对象，如图8-17所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581148043230-8c3937e5-4bc2-47f0-b002-7bc11c2b6c72.png)

图8-17 Name字符串

Name字符串（以字符串对象形式）存储到19F078地址。

## 8.4.6加密循环
继续调试，遇到如下循环，即一系列循环语句。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581148623853-053e6eef-14d5-48b3-be97-d508cec81a23.png)

简单讲解上述循环的动作原理，就像在链表中使用next指针引用下一个元素一样，_vbaVarForlnit()、__vbaVarForNext()可以使逆向分析人员在字符串对象中逐个引用字符。并且设置loop count（EBX）使其按指定次数运转循环。

提示------------------------------------------------------------------------------------------------------------------

实测仅使用接收的Name字符串中的前4个字符。在代码内检查字符串的长度，若少于4个字符，就会弹出错误消息框。

-----------------------------------------------------------------------------------------------------------------------

至此我们已经查找到了所有希望查看的部分，接下来了解一下加密方法。

## 8.4.7加密方法
PS:输入的Name字符串为“ReverseCore”。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581148870151-de1f2004-cffc-457e-831a-a234215340f2.png)![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581148871016-4333c4e7-8ab5-4838-95cc-4636c112a589.png)

在40323D中下断点，按F9调试至此，看一下栈：（中文为乱码，因此借用一下书上的）

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581149832899-de5b62a1-39c5-47ee-ab2f-c86447d6a91e.png)

运行如下函数，将加密后的值存储到ECX寄存器所指的缓冲区。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581149968947-d2d0dd17-17b3-464d-92b2-6db9e9f09025.png)

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581150087625-49db9696-3ef8-41af-b7f3-d7ffe6624899.png)

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581150156378-a5a97283-68b7-480e-a65a-5bc3d1f5e014.png)

加密方法整理如下。

（1)从给定的Name字符串前端逐一读取字符（共4次）。

（2）将字符转换为数字（ASCII代码）

（3）向变换后的数字加64。

（4）再次将数字转换为字符。

（5）连接变换后的字符。

# 8.5小结
从破解层面看，示例是个很容易说明的文件。但对于代码逆向分析初学者而言，其中包含了大量内容（VB文件、字符串加密），若要一一学习，分量就显得非常多。

若跟随调试时进展不顺，请不要轻易放弃。看着上面的说明，各位可能会觉得我调试得过于简单了（特别是讲解有关事件处理程序代码的部分），但是我为了编写该章节已经重启了10多次。

错过要查找的代码时就要重启调试，需要不断重启以跟踪VB字符串对象内部的字符串缓冲区。各位也要经历这样一个过程才能提高调试水平。因此，现在暂时跳过还不懂的部分，达到一定水平后再挑战。

# Q&A
Q.除了前面介绍的方法，还有别的方法吗?

A.当然，还有很多呢。破解方法不是一成不变的。即便是同一个文件，也可以尝试使用不同方法，不断尝试才能提高水平。



Q.破解很多crackme文件能够帮助提高逆向分析水平吗?

A.的确对提高逆向分析水平有一定帮助，但我建议初学者分析crackme是想让他们感受代码逆向分析的乐趣。代码逆向分析领域中要学习的内容非常多，若感受不到其中的乐趣很容易半途而废。所以，**<font style="color:#F5222D;">如果通过分析crackme文件感受到了逆向分析的乐趣，学习起来就不会觉得太难。但也不要过分沉溺于crackme程序的分析，只要能从中感受到乐趣足矣。</font>**



Q.“调试到403329”的含义是“在403329地址处设置断点，然后运行Run（F9）命令”吗?

A.使用断点可快速到达指定位置。也可使用StepInto（F7)/StepOver(F8)命令调试到相应地址处。



**<font style="color:#F5222D;">Q.如图8-10所示，若想查看栈内存，该怎么办呢？?</font>**

**<font style="color:#F5222D;">A.在OllyDbg的Dump窗中使用移动命令（Ctrl+G)即可。或者在图8-9的栈窗口中选择12FAB8，再选择鼠标右键菜单中的Follow in dump项。抑或在图8-8中选择403321地址后，使用鼠标右键莱单中的Follow in dump-Memory Address命令。</font>**



Q.为何要在“TEST AX，AX”指令中比较2个一样的项？

A.为了检测AX是否为0。只要把它想成汇编语法的特征即可。比如图8-8的40332F地址处有如下指令：

TEST AX,AX

JE403408

将上述汇编代码转换为C语言语句，如下所示：

if(AX==0)

goto 403408

“原来汇编语法是这样子啊”，这样想就好。

Q.您如何在图8-14的代码中查找到了Check按钮的事件处理程序?

A.参考图8-6～图8-8的代码，把“Wrong serial”字符串定为目标，然后查找引用该字符串的代码（因为代码所属区域即是按钮的事件处理程序）。从查找到的代码开始，向上拖动滑动条，找到生成栈帧（函数开始）的部分。



Q.加密字符串的代码复杂难懂，看也看不明白，您是怎么知道的呢?

A.我找出“ReverseCore”字符串的地址后，在查找访问该字符串的代码过程中发现了加密代码。而且，仔细逐行调试也能发现。对于初学者而言，这些不是一下子就能理解的内容。**<font style="color:#F5222D;">不断努力、反复调试</font>**，就会慢慢明白。



Q.读取Name的位置是StackFrame形成后第四个call语句，您是如何知道的?

A.先找到处理程序再反复调试该代码。在此过程中边注意观察寄存器、栈边调试代码，就会看到如下指令。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581150619172-b49f46df-3f9f-4d52-91e2-4906882499d3.png)

上面00402FB6地址处的命令把字符串的地址设置到EAX寄存器。由此可以推出[EBP-88]变量即是字符串对象，且值是由00402F98地址处的CALL指令设置的。只要反复调试就会知道这一点，各位不断挑战后也终将了解。



Q.其他部分都明白，但加密部分太难了。除了不断调试外，还有别的方法吗？

A.有些读者初次接触这些汇编代码形式的加密代码，感到很难是十分正常的，我也一样。但可以明确告诉大家，即便一再抱怨，只要不断看代码，一个月、两个月…一年后就会觉得简单一些了。坚持就是胜利。



Q.为什么402ED0地址处没有Check按钮的注释?

A.这个注释是我为便于讲解手动添加的。由于没有特别说明，可能让大家误以为它是OllyDbg默认提供的注释。

