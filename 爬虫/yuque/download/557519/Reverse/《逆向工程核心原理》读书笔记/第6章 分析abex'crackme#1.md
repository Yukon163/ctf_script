本章我们将分析一个非常简单的crackme小程序，以进一步熟悉调试器与汇编代码。当然，我们的目标并不是为了破解（Crack)它，而是通过它来加深对汇编代码与调试技术的认识。

顾名思义，crackme就是“破解我”的意思，它们都是一些公开用作破解练习的小程序。作为代码逆向分析技术的初学者，尝试分析一些简单的crackme小程序可以验证自己掌握的技术，加深对调试器及汇编代码的认识。 

Abex'crackme就是这样一个简单的著名小程序，国内外有许多网站都对它进行了详细讲解与说明。将自己的破解方法与其他人的相比较，这样能进一步提高自己的水平。

# 6.1 abex'crackme#1
调试前先运行abex'crackme#1这个程序，大致了解一下它。

如图6-1所示，双击运行程序后弹出一个消息窗口，显示“Make me think your HD is a CD-Rom”消息。我刚开始并不理解这句英文。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581046969738-69e7c8c9-02ba-4435-9c01-6f7bca63ab75.png)

图6-1 运行程序

消息的最后部分出现了“CD-Rom”这个词，我们只能根据它大致推测出前面的HD为HDD（Hard Disk Drive)的意思。由于没有更多选择，我们继续按消息窗口中的“确定”按钮。

如图6-2所示，程序弹出Error消息窗后就终止运行了。但是abex到底想要干什么（要怎样破解什么）仍然不得而知。下面直接调试分析它，把握这个小程序的意图。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581047045990-4ff239f1-3c70-4a1a-85e9-b426ae035f45.png)

图 6-2 弹出消息框

提示------------------------------------------------------------------------------------------------------------------

大多数crackme小程序都让我们猜测序列号（serial key），但是abex#1稍显特殊。

-----------------------------------------------------------------------------------------------------------------------

## 6.1.1开始调试
首先运行OlyDbg软件载入小程序，代码窗口中可以看到程序的汇编代码，如图6-3所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581047198842-5a26b65d-f9ae-4d28-82ae-56aca47bab6a.png)

图 6-3 EP代码

EP代码非常短，它与我们前面分析的HelloWorld.exe有非常大的不同。这是因为abex'crackme程序是使用汇编语言编写出来的可执行文件。

使用VC++、VC、Delphi等开发工具编写程序时，除了自己编写的代码外，还有一部分启动函数是由编译器添加的，经过反编译后，代码看上去就变得非常复杂。但是如果直接使用汇编语言编写程序，汇编代码会直接变为反汇编代码。观察图6-3中的代码可以看到，main()直接出现在EP中，简洁又直观，充分证明了这是一个直接用汇编语言编写的程序。

## 6.1.2分析代码
由于代码非常简短，我们一点点地分析，重点看图6-3中右上部分关于Win32API调用的内容。

> MessageBox("Make me think your HD is a CD-Rom.")
>
> GetDriveType("C:\\")
>
> ...
>
> MessageBox("Nah...This is not a CD-ROM Drive!")
>
> MessageBox("OK,I really think that your HD is a CD-ROM!:p")
>
> ExitProcess()
>

如果之前大家从事过Windows应用程序的开发，那么对以上几个函数的含义应该非常了解。

从上述代码的分析中，我们能够准确把握程序制作者的真正意图。在消息窗口按“确定”后，程序会调用**GetDriveType()API，获取C驱动器的类型（大部分返回的是HDD类型）**，然后操作它，使之被识别为CD-ROM类型，再在消息窗口中输出“OK，I really think that your HD is a CD-ROM!ip”消息。下面逐行分析crackme的代码。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581048136186-0ab26f34-793f-4ccf-8d0b-ca4ab8a3598b.png)

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581048142791-70fefe72-1959-4406-afb7-a2498a657a77.png)

上述代码中使用的汇编指令并不难，但是对尚未熟悉汇编代码的朋友来说还是有一定难度的，所以我们在代码中添加了注释，阅读注释就能轻松理解各命令含义了。

提示-----------------------------------------------------------------------------------------------------------------

上述代码中使用的汇编指令说明如下。



| 指令 | 说明 |
| --- | --- |
| <font style="color:#262626;">PUSH</font> | 入栈指令 |
| <font style="color:#262626;">CALL</font> | <font style="color:#262626;">调用指定位置的函数</font> |
| INC | <font style="color:#262626;">值加1</font> |
| DEC | <font style="color:#262626;">值减1</font> |
| <font style="color:#262626;">JMP</font> | 跳转到指定地址 |
| <font style="color:#262626;">CMP</font> | 比较给定的两个操作数*与SUB命令类似，但操作数的值不会改变，仅改变EFLAGS寄存器（若2个操作数的值一致，SUB结果为0，ZF被置为1） |
| <font style="color:#262626;">JE</font> | <font style="color:#262626;">条件跳转指今（Jump if equal)*若ZF为1，则跳转</font> |


# 6.2破解
下面修改汇编指令代码来破解这个小程序。

提示------------------------------------------------------------------------------------------------------------------

代码逆向分析技术中，我们把有意将已有代码（或数据）覆盖为其他代码的行为称为“打补丁”（patch）。

------------------------------------------------------------------------------------------------------------------<font style="background-color:transparent;"> ----</font>

<font style="background-color:transparent;">首先移动光标到401026地址处，按空格键，在打开的汇编窗口中将汇编指令JE SHORT 0040103D更改为JMP 0040103D，如图6-4所示。</font>

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581048522693-fac6c669-3e37-4c79-a8f9-de4a977d5678.png)

图6-4修改汇编命令

换言之，通过汇编命令窗口将条件分支语句（JE）替换为无条件跳转语句（JMP），非常简单。

在OllyDbg中使用Copy to executable命令，可以把修改后的代码保存为文件，具体操作可以参考前面HelloWorld.exe中的相关内容。

# 6.3将参数压入栈
结束本章前，再向大家介绍一个代码逆向分析中比较重要的内容——函数调用时将函数参数压入栈的方法。

首先，请看地址00401000~0040100E之间的命令，可以发现调用MessageBoxA()函数之前使用了4个PUSH命令，把函数需要的参数**<font style="color:#F5222D;">逆序</font>**压入栈。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581048736083-b9423851-059f-47cf-963d-35aab996012b.png)

将上述汇编代码转换为C语言函数调用代码，如下所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581048812204-cb50d6b3-4a83-447d-9593-c2305593da2a.png)

比较C语言代码与汇编代码可以看到，函数调用时的参数顺序（正序）与参数入栈时的顺序（逆序）相反。那么参数入栈时，为什么要采用这种逆序的方式呢？要想理解这个问题，想想栈内存结构（FILO，First In Last Out或LIFO，Last In First Out)即可。

> “栈的结构是FILO（先进后出），所以把参数压入栈时，只有按照逆序的方式压入，MessageBoxA()函数才能以正确的顺序接收到这些参数。”
>

利用调试器执行到**EIP=0040100E**地址处，观察右下角**栈窗口**，如图6-5所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581049023678-db2cf0ec-b4c2-48c2-8706-d831ec27e475.png)

图6-5 栈

x86环境下，栈向低地址延伸（即向栈压入数据时，~~EPS~~（ESP）值减小，向低地址方向移动），观察图6-5中的栈窗口可以看到，MessageBoxA()函数的第一个参数在栈顶位置，最后一个参数（第四个参数）在其他参数下面，从PUSH命令执行的顺序可以很容易地理解这点。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581049165403-de7451a3-f089-4144-91ff-b50a5874569f.png)

（可以将图6-5与上图比较，发现两张图的顺序相反）

MessageBoxA()函数从栈中获取需要的参数时，存储在栈中的参数会按照FILO（先进后出）的规则依次弹出。从MessageBoxA()函数获取参数的角度来看，参数就像按照原来顺序被存入栈一样。

# 6.4小结
本章的破解方法虽然简单，但为初次接触这方面内容的朋友进行了详细讲解。此处的破解仅仅是为了更好地学习代码逆向分析技术而做的练习，希望大家将重点放在进一步学习高级代码逆向分析技术上，打好基础。

# Q&A
Q.分析代码时，从MessageBoxA(）函数的注释中可以看到，ESI被设置为了0xFFFFFFFF，这是怎么知道的呢？

A.在调用MessageBoxA0函数的地址处按F8键（StepOver），ESI就会改变。实际上，**Win32API被调用后，某些特定寄存器的值就会改变**，编写Win32汇编程序时要特别注意这一点。



Q.为什么会有垃圾代码?

A.调试时，这些代码被故意插入汇编代码来迷惑代码逆向分析人员。



Q.调试时，将401023地址处的“DEC EAX”命令替换为NOP命令，然后按F9命令运行程序，程序破解成功。但把更改保存为文件后执行时，破解却失败了，请问为什么会出现这种情况？

A.**<font style="color:#F5222D;">首先，这种破解尝试是非常值得表扬的。但本例中选择在401023处破解是不合适的，这是因为在不同版本的操作系统，如WinXP/7中，结果值是不同的，而且在不同版本的OllyDbg1.1/1.2中也是不一样的。虽然破解方法多种多样，但最好从受外部影响最小的条件分支语句入手破解。</font>**强烈的好奇心与实践精神是学好代码逆向分析技术的原动力，经历过很多错误后，方能成为一名出色的代码逆向分析专家。

