一位名叫Lena的人在[https://tuts4you.com/](https://tuts4you.com/)公示板上贴了40个crackme讲座，以帮助初学者学习代码逆向分析技术。这些讲座非常受欢迎，因为所有讲座都以Flash视频形式呈现出来，且让学习者感到非常亲切。各位可以链接到tuts4you网站观看这些视频讲座，这对学习代码逆向分析技术非常有帮助。

# 11.1运行
首先运行要破解的文件。

    - 弹出消息对话框，显示2条信息。
    - 删除所有烦人的Nags（唠叨）

查找registration code选择“确认”按钮，显示主窗口，如图11-2所示。

   这是个典型的serial crackme程序。阅读画面中的蓝色文字，要求使用SmartCheck注册（SmartCheck是Numega公司制作的实用程序，是破解者喜欢使用的工具之一。本书仅使用调试器进行调试破解）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163205225-01b8ec63-3c0a-4b8e-aba0-ddf02941df18.png)

图11-1 初始消息框

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163206260-28e021d0-2886-4cbc-91c5-46f7afa77d10.png)

图11-2 主画面

提示------------------------------------------------------------------------------------------------------------------

若示例文件（Tut.ReverseMel.exe)无法运行，请先将附带的MSVBVM50.dll文件复制到示例目录下再运行。

-----------------------------------------------------------------------------------------------------------------------

# 11.2分析
## 11.2.1目标（1）：去除消息框
第一个目标是去掉Nag消息框，即图11-1中的消息框。开始运行程序，或单击图11-2中的“Nag?”按钮时，就会弹出该消息框。使用OllyDbg打开文件。

图11-3的代码看上去非常眼熟，其实就是abex crackme2中看到过的Visual Basic代码。（看到00401162地址的MSVBVM50.ThunRTMain函数了吗?）

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163415037-e476870d-9859-4ccb-ab71-db40ed101ec8.png)

图11-3 EP代码

这一次也来预测一下代码。要去除消息框，只要操作调用消息框的函数部分即可。**Visual Basic中调用消息框的函数为MSVBVM50.rtcMsgBox。**

在OllyDbg中使用鼠标右键菜单的Search for-All intermodular calls（右键->查找->模块间的调用）命令，将会列出程序中调用的API目录，如图11-4所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163772769-3b0e4af7-62ef-4d4c-901d-a07da66a4631.png)![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163773630-3484b21c-eaf6-41d6-bc68-8545930944c4.png)

图11-4 All intermodular calls

在图11-4中选择Destination（目标文件）栏目，根据函数名称排序。共有4处调用要找的tcMsgBox函数。

选择鼠标右键菜单中的Set breakpoint on every call to rtcMsgBox（在每个调用到rtcMsgBox上设置断站）菜单，在所有调用rtcMsgBox的代码处设置断点，如图11-5所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163833228-3270e011-0ac6-47de-a0a2-8ae262b9e575.png)

图11-5在调用rtcMsgBox代码处设置断点

然后（回到原来的调试器窗口中）在调试器中按F9键运行程序。程序运行到设有断点的地方就停下来，如图11-6所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581163992517-b7d5e982-3ce3-4a08-8099-26ae4284e15c.png)

图11-6 运行到402CFE地址处停止

程序运行到402CFE地址处就停下来，稍微向上拉一下滚动条，可以看到图11-1消息框中显示的字符串。该部分就是程序开始运行时用来显示消息框的代码部分，终于找到了。

继续运行程序（F9），弹出图11-1中的消息框，选择“确定”按钮，显示出图11-2的主画面。在主画面中按下“Nag?”按钮会发生什么呢？程序运行到图11-6的地址（402CFE）处停下来。（这样做效果可能不明显，可以让代码运行到其他地方再按下“Nag?”按钮）最初显示的消息框与按主画面中“Nag?”按钮显示的消息框有相同的运行代码。所以只要对一处“打补丁”即可。

## 11.2.2打补丁（1）：去除消息框
打补丁的方法很多。

### 第一次尝试
先修改402CFE地址处的CALL命令，如下所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581164558349-2e5ac36e-ee72-4189-8a20-03d0389319d2.png)

**原来：**

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581164439095-5208e46d-bd43-482d-809e-fd9717a9e61b.png)

**修改后：**

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581164512567-8d34b4b9-c1d0-47c5-ad81-6e2384557f87.png)

2个字节，以保证代码不会乱（原来CALL命令的大小为5字节，ADD命令用3个字节，还余下2个字节）。

看上去没有什么问题，但结果却“发生错误”。原因在于没有正确处理rtcMsgBox()函数的返回值（EAX寄存器）。

**如图11-7，在402CFE地址处调用rtcMsgBox()函数后，**~~**402D06**~~**（402D0C）地址处将返回值（EAX）存储到特定变量（EBP-9C)。此处消息框的返回值应该是1（表示“确定”按钮）。若存储的为1之外的值，则表示程序终止。**那么最好试试其他方法。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581164962628-bdf1823f-3cc0-4f1d-9b7d-cb4e9d349112.png)图11-7 402CFE地址处的rtcMsgBox()调用

<font style="color:#F5222D;">提示------------------------------------------------------------------------------------------------------------------</font>

<font style="color:#F5222D;">（1）可以修改402CFE地址处的指令，如下所示。</font>

<font style="color:#F5222D;">ADD ESP,14(Instruction:83C414)</font>

<font style="color:#F5222D;">MOV EAX,1(Instruction:B801000000)</font>

<font style="color:#F5222D;">以上两行汇编代码产生的结果与调用rtcMsgBox()函数后用户按“确定”按钮的结果相同（栈与返回值相同）。之所以没有这样做是因为指令长度不合适。源文件402CFE地址处的命令长度为5字节，但上面2行汇编命令的长度为8个字节，因此会侵占到后面的代码。</font>

<font style="color:#F5222D;">（2）×86（IA-32)系统中使用EAX寄存器传递函数的返回值。</font>

<font style="color:#F5222D;">（3）关于IA-32指令的说明请参考第49章。</font>

<font style="color:#F5222D;">-----------------------------------------------------------------------------------------------------------------------</font>

### 第二次尝试
在图11-6的代码中略微向上拖动滚动条，可以看到402C17地址处表示函数开始的栈帧prologue,如图11-8所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581165282389-ac431f79-b091-442a-8ee5-e9c727d29c74.png)

402CFE的rtcMsgBox函数调用代码也是属于其他函数内部的代码。所以如果上层函数无法调用，或直接返回，最终将不会调用rtcMsgBox函数。像下面这样修改401C17处的指令（使用Assemble Space指令）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581165372156-921aafbe-0bb5-4323-9134-b65aeb1a1991.png)

注意------------------------------------------------------------------------------------------------------------------

要根据传递给函数的参数大小调整栈（RETN XX）。

-----------------------------------------------------------------------------------------------------------------------

至此就成功去除消息框。

如何查看402C17函数的参数个数-------------------------------------------------------------------------------------

确认402C17函数的起始代码存储在栈中的返回地址（7401E5A9）（让执行流运行到402C17，查看栈窗口），如图11-9所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166122812-62d09260-6ee9-4d44-8ae5-3912d9489308.png)

图11-9 返回地址

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166245401-72a42a06-ad91-481d-ab88-a5eca808e888.png)

图11-10 MSVBVM50.dll模块

如图11-10所示进入返回地址（7401E5A9）。该代码区域是MSVBVM50.dll模块区域。执行7401E5A7地址处的CALL EAX指令后即返回7401E5A9地址处。再次运行调试器（Ctrl+F2），在7401E5A7地址处设置断点后运行程序（F9），可以得知EAX的值为402656。

转到402656地址处，最终跳转到402C17地址，如图11-11所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166406276-edfbeee0-fdfc-4429-a377-dd8b157875e1.png)

图11-11 402656地址处的代码

综合图11-10与图11-11可以发现，7401E5A7地址的CALL EAX命令最终调用的是402C17地址处的函数。所以，确认CALL EAX命令（7401E5A7）调用前后的栈地址即可得知402C17函数参数的个数（因使用的是stdcall调用方式，所以栈由被调用者负责清理）。

-----------------------------------------------------------------------------------------------------------------------

## 11.2.3目标（2）：查找注册码
第二个目标是查找注册码（Registration Code)。先如图11-12所示，单独运行程序（不使用OD进行调试）输入任意值试试。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166565302-6ea5b206-d83d-43fd-9cb6-ca4194d4e5e7.png)

    图11-12“RegCode is wrong!”消息框

弹出对话框显示，输入的是错误的注册码。在OllyDbg中检索错误消息字符串（鼠标右键菜单Search for-All referenced text strings)，如图11-13所示。

查看402A69地址处的代码，如图11-14所示（双击鼠标）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166727693-3924fbfb-5db6-46c8-b47f-1fd28ac17a4f.png)

图11-13 All referenced text strings

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166906127-932d9ec0-4f6d-4e0c-a1e7-77801e37b7b0.png)

图11-14402A69地址处的代码

看图中代码，402A2A地址处有“I'mlena151”字符串，其下方的402A2F地址处是__vbaStrCmp()函数调用代码。vbaStrCmp()API是VB中比较字符串的函数，在本例中用于比较用户输入的字符串与“I'mlena151”字符串。出乎意料的是很容易就发现了它。向上略微拖动滚动条。

输入正确的注册码后，图11-15中的代码用于弹出成功消息框。(“Yep!You succeeded registering！”）

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581166974132-fe66a6f4-724a-4c84-9bc5-f9dc3f5e4c0d.png)

地址4028BD处也存在“I'mlena151”字符串，其下即是__vbaStrCmp函数。因此可以肯定注册码就是“I'mlena151”字符串。

如图11-16所示，成功找到正确注册码。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581167183907-b18a9c76-3a8f-4b38-8abf-b352c5549f2a.png)

图11-16 成功消息框

# 11.3小结
本示例中的crackme用作练习程序，破解起来相当简单。各位可以访问前面介绍的[https://tuts4you.com/](https://tuts4you.com/)网站，观看程序原作者lena的视频讲解，这对了解整个程序非常有帮助。此外，每个人分析程序的方法各不相同，大家可以多学习别人是如何分析程序的，这对提高自身的逆向分析水平非常有用。

# Q&A
Q.图11-8中要跳转的地址显示为红色，这是如何做到的呢？

A.在OllyDbg的CPU选项卡（选项->调试设置->CPU选项卡）中点选Show jump path（显示跳转路径）、Show grayed path if jump is not taken（如跳转未实现则显示灰色路径）、Show jumps to selected command（显示跳转到选定命令的路径）项即可。

