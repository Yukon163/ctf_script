# 21.1钩子
英文**Hook一词，翻成中文是“钩子”、“鱼钩”的意思，泛指钓取所需东西而使用的一切工具。**“钩子”这一基本含义延伸发展为“**偷看或截取信息时所用的手段或工具**”。下面举例向各位进一步说明“钩子”这一概念。

**“钩子”的概念**

假设有一个非常重要的军事设施，其外围设置了3层岗哨以进行保护。外部人员若想进入，需要经过3层岗哨复杂的检查程序（身份确认、随身物品查验、访问事由说明等）。若间谍在通往该军事设施的道路上私设一个岗哨，经过该岗哨的人员未起疑心，通过时履行同样的检查程序，那么间谋就可以坐享其成，轻松获取（甚至可以操纵）来往该岗哨的所有信息。

像这样，为了偷看或截取来往信息而在中间设置岗哨的行为称为“挂钩”（或“安装钩子”）**实际上，偷看或操作信息的行为就是人们常说的“钩取”（Hooking)。**

   “钩取”技术广泛应用于计算机领域。其实，我们不仅可以查看来往于“OS-应用程序-用户”之间的全部信息，也可以操作它们，并且神不知鬼不觉。具体方法有很多，其中最基本的是“**消息钩子”（Message Hook）**，下面会详细介绍。

提示------------------------------------------------------------------------------------------------------------------

“钩取”是代码逆向分析中非常重要且有趣的主题，后面会逐一介绍各种“钩取”方法。

-----------------------------------------------------------------------------------------------------------------------

# 21.2消息钩子
Windows操作系统向用户提供GUI（Graphic User Interface,图形用户界面），它以事件驱动（Event Driven)方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是**事件**（Event）。发生这样的事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作（上述过程在《Windows程序设计》一书中有详尽说明）。也就是说，敲击键盘时，消息会从OS移动到应用程序。**所谓的“消息钩子”就在此间偷看这些信息**。为了帮助各位进一步理解它，下面以键盘消息为例说明。请看图21-1。

**<font style="color:#000000;">先讲解常规Windows消息流。</font>**

    - **<font style="color:#000000;">发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。</font>**
    - **<font style="color:#000000;">OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。</font>**
    - **<font style="color:#000000;">应用程序（如记事本）监视自身的[application message queue]，发现新添加的 WM KEYDOWN消息后，调用相应的事件处理程序处理。</font>**

正如在图21-1中看到的一样，OS消息队列与应用程序消息队列之间存在一条“**钩链**”（HookChain)，设置好键盘消息钩子之后，处于“钩链”中的**键盘消息钩子会比应用程序先看到相应信息**。在键盘消息钩子函数的内部，**除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截阻止消息传递。**

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581555966150-ea0a8179-288d-4e77-b692-1b21b5a80525.png)

提示------------------------------------------------------------------------------------------------------------------

可以同时设置多个相同的键盘消息钩子。按照设置顺序依次调用这些钩子，它们组成的链条称为“**钩链**”。

-----------------------------------------------------------------------------------------------------------------------

像这样的消息钩子功能是Windows操作系统提供的基本功能，其中最具代表性的是MS Visual Studio中提供的**SPY++，它是一个功能十分强大的消息钩取程序，能够查看操作系统中来往的所有消息。**

# 21.3 SetWindowsHookEx()
使用SetWindowsHookEx() API可轻松实现消息钩子，SetWindowsHookEx() API的定义如下所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581556303198-5400582c-4f98-48da-889c-efefe1f594a9.png)

**钩子过程（hook procedure)**是由操作系统调用的**回调函数**。安装消息“钩子“时，**“钩子”过程需要存在于某个DLL内部，且该DLL的示例句柄（instance handle)即是hMod**。

提示------------------------------------------------------------------------------------------------------------------

若dwThreadID参数被设置为0，则安装的钩子为“全局钩子”（Global Hook），它会影响到运行中的（以及以后要运行的）所有进程。

-----------------------------------------------------------------------------------------------------------------------

像这样，使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件**强制注入（injection)**相应进程，然后调用注册的“钩子”过程。注入进程时用户几乎不需要做什么，非常方便。

# 21.4键盘消息钩取练习
本节将做一个简单的键盘消息钩取练习，以进一步加深各位对前面内容的理解。请看图21-2。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581556566616-4d8f2db0-acc9-49ad-8aa2-cb3e8ccc6cb5.png)

KeyHook.dll文件是一个含有钩子过程（KeyboardProc)的DLL文件。HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。**HookMain.exe加载KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子（KeyboardProc）。若其他进程（explorer.exe、iexplore.exe、notepad.exe等）中发生键盘输入事件，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc****()****函数。**

这里需要注意的一点是，**OS会将KeyHook.dll强制加载到发生键盘输入事件的所有进程。**换言之，消息钩取技术常常被用作一种**DLL注入技术**（后面会单独讲解DLL注入的相关内容）。

## 21.4.1练习示例 HookMain.exe
本节通过示例来练习一下键盘钩取技术，拦截notepad.exe进程的键盘消息，使之无法显示在记事本中。

**运行HookMain.exe-安装键盘钩子**

首先运行HookMain.exe程序，如图21-3所示。

运行HookMain.exe程序后，输出“press‘q'to quit!”信息，提示在HookMain.exe程序中输入“q”即可停止键盘钩取。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581556937815-3ed384cb-8117-4088-8914-32c61103c124.png)

    图21-3运行HookMain.exe

**运行Notepad.exe程序**

当前系统中已安装好键盘钩子。运行Notepad.exe，用键盘输入。

如图所示，Notepad.exe进程忽视了用户的键盘输入。使用Process Explorer查看notepad.exe进程，可以看到KeyHook.dll已经加载其中（参考图21-4）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557246855-345113e2-568c-4560-aab8-3a49c65d0043.png)

在Process Explorer中检索注入KeyHook.dll的所有进程，如图21-5所示。一个进程开始运行并发生键盘事件时，KeyHook.dll就会注入其中（**但其实忽视键盘事件的仅有notepad.exe进程，其他进程会正常处理键盘事件**）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557413584-0e231e4f-5c08-4603-b716-df8d76de6f97.png)

**HookMain.exe终止-拆除键盘钩子**

如图21-6所示，在HookMain.exe程序中输入“q”命令，HookMain.exe将拆除键盘钩子，并终止运行。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557511093-9d09a4ad-3a08-4299-ba30-49ec8eaa429b.png)

拆除键盘钩子后，在notepad.exe（记事本）中使用键盘输入，可以发现记事本又能正常接收了。在Process Explorer中检索KeyHook.dll会发现，无任何一个进程加载KeyHook.dll，如图21-7所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557596619-28f8c962-55ef-450c-a582-404bf1779561.png)

拆除键盘钩子后，相关进程就会将KeyHook.dll文件全部卸载（Unloading）。

## 21.4.2分析源代码
下面分析一下示例的源代码。

提示------------------------------------------------------------------------------------------------------------------

示例是使用MS Visual C++ 2010 Express Edition编写的，已在WindowsXP/7（32位）环境中通过测试。为便于讲解，我已经去除了示例代码中的返回值/错误处理语句。

**HookMain.cpp**

首先看一下HookMain.exe文件的源代码（HookMain.cpp）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557747127-48b47bbb-2258-4281-a80d-2bf0efcc10ce.png)

源代码非常简单。先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入“q”

   时，调用HookStop()函数终止钩取。重要代码处添加了注释，认真查看就能轻松理解，不会遇到什么困难。

**KeyHook.cpp**

接下来继续看KeyHook.dll文件的源代码（KeyHook.cpp)。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557933824-cd174f4a-7c79-4e9d-929c-11d57dad576c.png)![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581557935076-52cdaa15-bee4-4d97-9e8b-390e2acdb4b2.png)

DLL代码也非常简单。调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。

提示------------------------------------------------------------------------------------------------------------------

MSDN中对KeyboardProc函数的定义如下：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581558105075-3240eb0e-7b95-426f-90c7-d9ccdbbb46e9.png)

上面3个参数中，wParam指用户按下的键盘按键的虚拟键值（virtual key code)。对键盘这一硬件而言，英文字母“A”与“a”具有完全相同的虚拟键值。参数IParam根据不同的位具有多种不同的含义（repeat count、scan code、extended-key flag、context code、previous key-state flag、transition-state flag)。使用ToAscii()API函数可以获得实际按下的键盘的ASCII值。

-----------------------------------------------------------------------------------------------------------------------

安装好键盘“钩子”后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程。加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc)。

KeyboardProc()函数中发生键盘输入事件时，就会比较当前进程的名称与“notepad.exe”字符串，若相同，则返回1，终止KeyboardProc()函数，这意味着截获且删除消息。这样，键盘消息就不会传递到notepad.exe程序的消息队列。

> 因notepad.exe未能接收到任何键盘消息，故无法输出。
>

除此之外（即当前进程名称非“notepad.exe”时），执行return CallNextHookEx(ghHook,nCode,wParam,IParam)；语句，消息会被传递到另一个应用程序或钩链的另一个“钩子”函数。

提示----------------------------------------------------------------------------------------------------------------- 

监视或记录用户键盘输入的程序被称为“键盘记录器”（Key Logger)。有些键盘记录器本身是PC恶意代码，通过钩取键盘消息，在PC用户不知情的情况下盗走用户的键盘输入，其工作原理与KeyHook.dll的工作原理基本一致。

-----------------------------------------------------------------------------------------------------------------------

# 21.5调试练习
本节将学习有关Windows消息钩取调试的技术。

## 21.5.1调试HookMain.exe
先调试用来安装键盘钩子的HookMain.exe。请使用OllyDbg打开HookMain.exe文件，如图21-8所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581559047634-f55dd698-8dd1-46db-a40e-c13d72e31182.png)

图21-8HookMain.exe的EP代码

图21-8显示的是HookMain.exe的EP代码，它是典型的VC++启动函数，其中最受关注的是开始进行键盘钩取的部分。

查找核心代码有几种方法可以帮助我们找到关注的核心代码：

    - 逐行跟踪。
    - 检索相关API。
    - 检索相关字符串。

第一种方法是程序无法正常运行或难以预测时使用的下策，此处略去不谈。这样就剩下后面2种方法（检索API或字符串）了。

由于已经运行过HookMain.exe程序，我们知道了该程序的功能（键盘钩取）与输出的字符串，所以下面要使用检索字符串（图21-3的“press'q'to quit!”)的方法。引用该字符串代码的前后就是我们关注的代码。在OllyDbg的代码窗口中，选择鼠标右键菜单中的Search for-All referencedtext strings项（参考图21-9）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581559357651-457ecf24-9dc7-4d73-8831-eefec7da9555.png)

弹出字符串窗口，如图21-10所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581559440125-8d347e94-aaa8-47fa-a27a-9686cd6444c2.png)

从图21-10中可以看到，40104D地址处的指令引用了要查找的字符串。双击字符串，转到相应地址处（40104D）。

图21-11中显示的代码其实就是HookMain.exe程序的main()函数（借助OllyDbg的字符串检索功能即可轻松找到）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581559575454-e5ab731e-c0f1-4e0b-ba2f-6e127fb52929.png)

调试main()函数在401000地址处设置断点，然后运行程序，到断点处停下来，开始调试。从断点开始依次跟踪调试代码，可以了解main()中的主要代码流。先在401006地址处调用LoadLibrary（KeyHook.dll)，然后由40104B地址处的CALL EBX命令调用KeyHook.HookStart()函数。跟踪40104B地址处的CALL EBX命令（StenInto（F7)).出现图21-12所示的代码。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581559792504-fbada483-0930-4416-bf04-0b755ed5f36e.png)

图21-12中的代码是被加载到HookMain.exe进程中的KeyHook.dll的HookStart()函数（请确认一下图中的地址区域）。在100010EF地址处可以看到CALL SetWindowsHookExW()指令，其上方10010E8与100010ED地址处的2条PUSH指令用于把SetWindowsHookExW()API的第1、2两个参数压入栈。

SetWindowsHookExW()API的第一个参数（idHook）值为WH_KEYBOARD(2)，第二个参数（lpfn)值为10001020，**该值即是钩子过程的地址**。后面调试KeyHook.dll时再仔细看该地址。

HookMain.exe的main()函数（401000)的其余代码接收到用户输入的“q”命令后终止钩取。以上内容非常简单，希望各位亲自调试。

## 21.5.2调试Notepad.exe
进程内的KeyHook.dll本小节将调试KeyHook.dll中的钩子过程，此时KeyHook.dll已被注入notepad.exe进程。首先使用OllyDbg打开Notepad.exe程序（也可以使用Attach命令打开运行中的notepad.exe进程）。通过OllyDbg中的“运行”（F9）命令使notepad.exe进程正常运行（参考图21-13）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581560383476-e9a45a26-bda0-457f-8bed-27f0c37fba5c.png)

如图21-14所示，在OllyDbg的Debugging options中，点选Break on new module(DLL）复选框。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581560449599-37ba819a-1d4f-4bee-98c5-4f7a22cc4479.png)

开启该选项后，每当新的DLL装入被调试（Debuggee)进程时就会自动暂停调试（这在“从DLL注入时开始调试”的情况下非常有用）。

此时运行HookMain.exe（参考图21-3)。然后在notepad.exe中使用键盘输入，此时OllyDbg暂停调试，并弹出Executable modules窗口。

如图21-15所示，KeyHook.dll被加载到10000000地址处。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581560586315-f1d5a502-4f8f-4a44-beda-7e9db4a1907f.png)

提示------------------------------------------------------------------------------------------------------------------

根据系统环境不同，有时不会先显示KeyHook.d11，而是先加载其他DLL库。此时按（F9）运行键，直到KeyHook.dll加载完成。有些系统无法正常运行该功能，此时使用OllyDbg2.0即可保证运行顺畅。

-----------------------------------------------------------------------------------------------------------------------

如图21-15所示，双击KeyHook.dll转到KeyHook.dll的EP地址处。由于我们已经知道钩子过程的地址为10001020，下面直接转到该地址处（请先在OllyDbg中取消对Break on new module(DLL)项的选择，使其处于“未选中”状态）。

   如图21-16所示，向“钩子”过程（10001020）设置断点，每当notepad.exe中发生键盘输入事件时，调试就停在该处。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581560827545-f3b87b15-ed31-4659-91a9-dea07333e778.png)

在栈中可以看到KeyboardProc）函数的参数。最后，将以上操作过程按顺序整理如下：

        * 用OllyDbg运行notepad.exe（或者Attach运行中的notepad.exe)；
        * 开启Break on new module（DLL)选项；
        * 运行KeyLogger.exe→安装global keyboard message hook；
        * 在notepad中使用键盘输入→发生键盘消息事件（按键a输入）；
        * KeyLogger.dl1被注入notepad.exe进程；
        * 在OllyDbg中向KeyboardProc（钩子进程）设置断点。

关于KeyboardProc()函数（10001020）可以参考前面源代码说明中的相关内容，请各位自己调试

# 21.6小结
本章讲解了Windows消息钩取技术与DLL钩子过程调试方法。这些知识在代码逆向分析中起着非常重要的作用，希望各位认真学习并掌握。特别是要反复练习“从DLL的EP代码开始调试”的方法，直到完全掌握。

# Q&A
Q.**<font style="color:#F5222D;">回调函数（CALLBACK）是什么？</font>**

A.**<font style="color:#F5222D;">简言之，就是某个特定事件发生时被指定调用的函数。</font>**窗口Windows过程（WndProc)就是一个典型的回调函数（键盘、鼠标等事件发生时OS会调用注册的窗口过程）。



**<font style="color:#F5222D;">Q.我是超级菜鸟，几乎什么都不懂，应该从哪儿开始学啊？从C语言开始吗?</font>**

A.其实，只有具备一定的Win32编程知识，才能较好地理解示例中的代码（当然也要有一定的C语言知识）。初**<font style="color:#F5222D;">次接触代码逆向分析时会遇到大量术语，这些术语往往让人一头雾水、不知所措。</font>**“这些都是学习代码逆向分析技术的绊脚石”，我（直到几年）之前一直这样想。但是看到那些没有以上知识却依然能够将代码逆向分析做得很棒的人，我的想法慢慢改变了。

我认识的代码逆向分析人员中，有几个人学习逆向分析技术时根本就不怎么懂C语言，他们学习时每当遇到C语言代码就直接敲一下，不断查找询问，后面就慢慢弄懂了。**<font style="color:#F5222D;">学习过程中遇到不懂的术语就记下来（初次看到会觉得难，但见过10次以后就不会这样想了）。</font>**

遇难而退不可取，反而应该谦虚谨慎、不骄不躁地去吸收更多新知识。他们现在都成为代码逆向分析技术的专家了呢。



Q.declspec函数是什么？

A.declspec是针对编译器的关键字，指出相应函数为导出函数。



Q.SetWindowsHookEx()API为什么在KeyHook.dll内部调用？您说它是安装钩子的APl?

A.是的。SetWindowsHookEx()API用于将指定的“钩子”过程注册到钩链中。无论在DLL内部还是外部均可调用（编程时怎么方便怎么来）。

