本章将调试UPX压缩的notepad_upx.exe程序，进一步了解运行时压缩的相关概念。**我们的目标是通过调试一点点地跟踪代码，最终找出原notepad.exe程序代码。最后再简单讲解一下经过UPX压缩的文件如何通过调试器。**

提示------------------------------------------------------------------------------------------------------------------

本章示例使用的是WindowsXPSP3中的notepad.exe程序。

-----------------------------------------------------------------------------------------------------------------------

# 15.1 notepad.exe的EP代码
首先看一下原notepad.exe程序的EP代码，如图15-1所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581304818773-15d7d256-b9bb-443f-8c0e-d87e12b22834.png)

图15-1 notepad.exe的EP代码

在010073B2地址处调用了GetModuleHandleA()API，获取notepad.exe程序的ImageBase（**基准位置**）。然后在010073B4与010073C0地址处比较MZ与PE签名。希望各位熟记原notepad.exe的EP代码。

# 15.2 notepad_upx.exe的EP代码
使用olyDbg打开notepad_upx.exe时，弹出图15-2所示的警告消息框。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581305044077-50b5ba64-074f-4eb7-82ae-2a1081a5842e.png)

图15-2OllyDbg警告消息框

调试器判断该文件为压缩文件，在“是”与“否”中**任选一个**，显示出**UPX EP**代码，如图15-3所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581305124985-5e9c6055-0141-4bef-aaca-73f54e48304c.png)

图15-3 notepad_upx.exe的EP代码

**EP地址为01015330，该处即为第二个节区的末端部分。**实际压缩的notepad源代码存在于EP地址（01015330）的上方。

下面看一下代码的开始部分（01015330）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581305344053-b337a0bd-0180-4ca4-9ff1-7cedee4dbf1f.png)

**首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈，**然后分别把**第二个节区的起始地址（01011000)**与**第一个节区的起始地址（01001000）**设置到**ESI**与**EDI**寄存器。**UPX文件第一个节区仅存在于内存。该处即是解压缩后保存源文件代码的地方。**

**调试时像这样同时设置ESI与EDI，就能预见从ESI所指缓冲区到EDI所指缓冲区的内存发生了复制。此时从Source（ESI）读取数据，解压缩后保存到Destination（EDI）。**我们的目标是跟踪图15-3中的全部UPX EP代码，并最终找到原notepad的EP代码，如图15-1所示。

提示------------------------------------------------------------------------------------------------------------------

+ 代码逆向分析称源文件的EP为OEP。
+ “跟踪”一词的含义是通过逐一分析代码进行追踪。
+ 实际的代码逆向分析中并不会逐一跟踪执行压缩代码，常使用自动化脚本、特殊技巧等找到OEP。但是对于初次学习运行时压缩文件的朋友而言，逐一跟踪代码才是正确的学习方法。

-----------------------------------------------------------------------------------------------------------------------

# 15.3跟踪UPX文件
下面开始跟踪代码，跟踪数量庞大的代码时，请遵循如下法则。

> **<font style="color:#F5222D;">“遇到循环（Loop）时，先了解作用再跳出。”</font>**
>

整个解压缩过程由无数循环组成。因此，只有适当跳出循环才能加快速度。

## 15.3.1OllyDbg的跟踪命令
跟踪数量庞大的代码时，通常不会使用Step Into（F7)命令，而使用OllyDbg中另外提供的跟踪调试命令，如表15-1所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581305889259-637b420b-7f8c-45d1-9a48-fdedc690bca2.png)

除了画面显示的之外，Animate命令与跟踪命令是类似的，由于Animate命令要把跟踪过程显示在画面中，所以执行速度略微慢一些。而两者最大的差别在于，**跟踪命令会自动在事先设置的跟踪条件处停下来，并生成日志文件。在UPX文件跟踪中将使用Animate Over(Ctrl+F8)命令**。

## 15.3.2循环#1
**在EP代码处执行Animate Over(Ctrl+F8)命令，开始跟踪代码。可以看到光标快速上下移动。**

**若想停止跟踪，执行Step Into（F7）命令即可。**

开始跟踪代码不久后，会遇到一个短循环。暂停跟踪（**执行Step Into（F7）命令**），仔细查看相应循环，如图15-4所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581306643524-5b6c9976-281a-4f63-86d5-02cb5a092101.png)

图15-4 第一个循环（要想出现图中的情况，可以在010153DD处F2下断点，然后执行F9）

循环次数ECX=36B，循环内容为“从EDX（01001000）中读取一个字节写入EDI（01001001）”。

EDI寄存器所指的01001000地址即是第一个节区（UPX0）的起始地址，仅存在于内存中的节区（反正内容全部为NULL）。

调试经过运行时压缩的文件时，遇到这样的循环应该跳出来。在010153E6地址处按F2键设置好断点后，按F9（F9：运行到断点处）跳出循环（取消之前在010153DD处F2下的断点）。

## 15.3.3循环#2
在断点处再次使用Animate Over(Ctrl+F8)命令继续跟踪代码，不久后遇到图15-5所示的循环（比前面那个循环略大一些）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581307390018-965c2b11-3b7c-457d-9da6-bc551caf8d35.png)

图15-5第二个循环（要想出现图中的情况，可以在01015402处F2下断点，然后执行F9）

该循环是正式的解码循环（或称为解压缩循环）。

先从ESI所指的第二个节区（UPX1)地址中依次读取值，经过适当的运算解压缩后，将值写入EDI所指的第一个节区（UPX0）地址。该过程中使用的指令如下：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581307071982-acd856b1-2eb2-4f10-97e0-3bd08efab06d.png)

只要在01015402地址处设置好断点再运行（F9），即可跳出第二个循环，如图15-5所示。运行到01015402地址后，在转储窗口中可以看到解压缩后的代码已经被写人第一个节区（UPX0）区域（01007000），如图15-5中原来用NULL填充的区域。

## 15.3.4循环#3
重新跟踪代码，稍后会遇到图15-6所示的第三个循环。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581307699499-d9c875f6-66c1-46cf-8549-163c3517a579.png)

图15-5第三个循环（要想出现图中的情况，可以在01015434处F2下断点，然后执行F9）

图15-6第三个循环该段循环代码用于恢复源代码的CALL/JMP指令（操作码：E8/E9）的destination地址。在01015436地址处设置断点运行后即可跳出循环。

到此几乎接近尾声了，只要再设置好IAT，UPX解压缩代码就结束了。

提示------------------------------------------------------------------------------------------------------------------

<font style="color:#F5222D;">对于普通的运行时压缩文件，源文件代码、数据、资源解压缩之后，先设置好IAT再转到OEP。</font>

**<font style="color:#F5222D;">IAT（Import Address Table，导入地址表）</font>****简言之，IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。**

-----------------------------------------------------------------------------------------------------------------------

## 15.3.5循环#4
重新跟踪代码，再稍微进行一段。

图15-7深色显示的部分即为设置IAT的循环。在01015436地址处设置EDI=01014000，它指向第二个节区（UPX1）区域，该区域中保存着原notepad.exe调用的API函数名称的字符串（参考图15-8）。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581308062235-5df12e48-6654-44a2-baf4-d72c398d258a.png)

图15-5第四个循环（要想出现图中的情况，可以在01015436处F2下断点，然后执行F9）

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581308146790-4d9bb746-6fd7-41bf-acdd-60255b433e42.png)

    图15-8 API名称字符串

UPX压缩原notepad.exe文件时，它会分析其IAT，提取出程序中调用的APl名称列表，形成API名称字符串。

用这些API名称字符串调用图15-7中01015467地址处的GetProcAddress()函数，获取API的起始地址，然后把API地址输入EBX寄存器所指的原notepad.exe的IAT区域。该过程会反复进行至API名称字符串结束，最终恢复原notepad.exe的IAT。

notepad.exe全部解压缩完成后，应该将程序的控制返回到OEP处。图15-9显示的就是跳转到OEP的代码。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581308357168-93da9623-dff2-4f8d-8b00-33629645470c.png)

图15-9 JUMP to OEP

另外，010154AD地址处的**POPAD命令与UPX代码的第一条PUSHAD命令对应**，用来把当前寄存器恢复原状（参考图15-3）。

最终，使用010154BB地址处的JMP命令跳转到OEP处，要跳转到的目标地址为0100739D，它就是原notepad.exe的EP地址（请各位确认）。

# 15.4快速查找UPX OEP的方法
各位都像上面这样顺利完成代码跟踪了吗?代码逆向技术的初学者一定要亲自试试，这有助于调试用其他压缩器压缩的文件。但每次都使用上述方法（跳出循环）查找OEP非常麻烦，实际代码逆向分析中有一些更简单的方法可以找到OEP（以UPX压缩的文件为例）。

## 15.4.1在POPAD指令后的JMP指令处设置断点
**UPX压缩器的特征之一是，其EP代码被包含在PUSHAD/POPAD指令之间。并且，跳转到OEP代码的JMP指令紧接着出现在POPAD指令之后。只要在JMP指令处设置好断点，运行后就能直接找到OEP。**

提示------------------------------------------------------------------------------------------------------------------

+ PUSHAD指令将8个通用寄存器（EAX~EDI）的值保存到栈。
+ POPAD指令把PUSHAD命令存储在栈的值再次恢复到各个寄存器。

-----------------------------------------------------------------------------------------------------------------------

## <font style="color:#000000;">15.4.2在栈中设置</font><font style="color:#F5222D;">硬件断点</font>
该方法也利用UPX的PUSHAD/POPAD指令的特点。在图15-3中执行01015330地址处的PUSHAD命令后，查看栈，如图15-10所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581308942094-8b5fed3c-cd69-48f7-b8dc-001f35e2a6cf.png)![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581308942823-7f804d27-1ea9-4860-8270-b9b196b0caaf.png)

EAX到EDI寄存器的值依次被存储到栈。从OllyDbg的Dump窗口进入栈地址（~~006FFA4  ~~000DFF54)。将鼠标光标准确定位到~~6FFA4~~DFF54地址，使用鼠标右键菜单设置硬件断点，如图15-11所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581309124027-c242e1c0-35ba-4aa7-98a2-dbab37978924.png)

硬件断点是CPU支持的断点，最多可以设置4个。与普通断点不同的是，设置断点的指令执行完成后才暂停调试。在这种状态下运行，程序就会边解压缩边执行代码，在执行POPAD的瞬间访问设置有硬件断点的（~~006FFA4  ~~000DFF54)地址，然后暂停调试。其下方即是跳转到OEP的JMP指令（熟悉该方法的操作原理才能在以后调试各种文件时得心应手）。

# 15.5小结
前面学习了有关调试UPX运行时压缩文件的内容。建议各位参照书中讲解亲自操作，通过逐一跳出各循环的方法查找OEP。经过这样一系列的实际操作后，相信各位的调试水平都会得到很大提高。

# Q&A
Q.解压缩（Unpacking)过程中打开Dump窗口，若不重新设置IAT就会出现初始化错误。这到底是怎么一回事？

A.比如，运行UPX文件后转储时，IAT中存在（对应于当前系统的）准确的API地址。但是INT却处于损坏状态。PE装载器使用INT中的API名称字符串（LoadLibrary()/GetProcAddress())来获取实际API地址，并将它们记录到IAT。由于INT已经损坏，该过程中自然会发生错误。



Q.很多汇编指令都不懂，请介绍可以查找汇编指令的网站吧，谢谢！

A.此时，我通常会去查Intel的官方文档：http://www.intel.com/products/processor/manuals/。



Q.如何知道ESI、EDI所指的地址对应于哪个节区的地址呢？我想知道该如何才能识别出恢复IAT的代码以及解码循环。

A.内存复制命令中，ESI指Source，EDI指Destination。所以使用PEView(或者OllyDbg的内存映射窗口）查看ESI/EDI所指的地址，即可知道它们对应的节区。从反复调用GetProcAddress()函数可知，这是在恢复文件的IAT。此外，如果拥有丰富的解压缩经验，就更容易预测，这是刚刚接触的人无法企及的。

