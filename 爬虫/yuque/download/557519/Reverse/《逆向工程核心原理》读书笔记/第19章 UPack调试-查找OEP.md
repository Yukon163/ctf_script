本章将调试UPack压缩的记事本（notepad upack.exe）文件以查找OEP。UPack会对PE文件头进行独特变形，但并未应用反调试技术（Anti-Debugging），调试起来并不费劲。

# 19.1OllyDbg 运行错误
由于UPack会将IMAGE OPTIONAL HEADER中的**<font style="color:#F5222D;">NumberOfRvaAndSizes值设置为A（默认值为10）</font>**，所以使用OlyDbg打开notepad_upack.exe文件时，初始检查过程中会弹出错误消息对话框，如图19-1所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581405888599-e139860a-5697-4b7f-9d3c-a94ed715ff6c.png)

图19-1OllyDbg的错误消息框

这不是什么非常严重的错误，按“确认”按钮关闭该对话框。上面这个错误导致OllyDbg无法转到EP位置，停留在ntdll.dll区域，如图19-2所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581407400814-1ba08e94-02bd-4e25-bf32-8ca1a81a3adb.png)

该现象是由OllyDbg的Bug（或者严格的PE检查）引起的，所以需要强制设置EP。首先要查找EP位于何处。下面使用Stud PE查找EP的虚拟地址。

如图19-3所示，ImageBase为01000000，EP的RVA为1018，经过计算可知EP的VA值为01001018。在OllyDbg的代码窗口中转到01001018地址处，使用New origin here命令强制更改EIP寄存器中的值，如图19-4所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581407662463-4a75e9ff-6643-4d4d-a2fa-a400a083a297.png)

图19-3 Stud_PE

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581407821459-477d4bda-5d97-4382-ac55-1892f27860f2.png)

执行New origin here命令时会弹出警告消息框，单击“确定”按钮，接下来就可以正常调试了。

<font style="color:#F5222D;">注意：新版调试器不会出现上述问题</font>

# 19.2解码循环
**所有压缩器中都存在解码循环（Decoding Loop)。**如果明白**压缩/解压算法本身就是由许多条件分支语句和循环构成的**，那么可能就会理解为何解码循环看上去如此复杂。

调试这样的解码循环时，应适当跳过条件分支语句以跳出某个循环。有些情况下循环较为复杂，无法迅速把握。调试中要仔细观察寄存器，注意相应值被写入哪些地址（其实这也需要丰富的经验）。

**<font style="color:#F5222D;">UPack把压缩后的数据放到第二个节区，再运行解码循环将这些数据解压缩后放到第一个节区。</font>**下面从EP代码开始调试，如图19-5所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581408313212-abe2aafe-2ea9-4723-9b06-8acb39a3706f.png)

前2条指令用于从010011B0地址**读取4个字节**，然后保存到EAX。EAX拥有值0100739D，它是原本notepad的OEP（分析一下**LODS DWORD PTR DS:[ES]指令可知，该指令从ESI所指的地址处读取4字节存储到EAX寄存器**）。事实上，如果事先知道该值是OEP，那么可以直接设置硬件析点，再按F9键运行，就会在OEP处暂停。

提示------------------------------------------------------------------------------------------------------------------

代码逆向技术人员谈及设置断点后运行时，常常使用“**挂断点跑程序**”这样的表达。

我们的目标是提高调试水平，所以继续调试（如果早已熟悉，挂上断点跑程序即可）。经过一阵调试后，会出现图19-6所示的函数调用代码。

-----------------------------------------------------------------------------------------------------------------------

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581408634743-777b7660-4867-42b6-8f4c-29b05912f1ff.png)

此时ESI的值为0101FCCB，该地址就是decode）函数的地址，后面会反复调用执行该函数。接下来略看一下decode）函数（101FCCB），如图19-7所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581408721915-681c555e-631c-42e9-a509-1c7277cde6d4.png)

仅从这部分来看，还搞不清楚这段代码的用途。使用Steplnto（F7）命令继续跟踪调试，遇到图19-8所示的代码。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581408787111-f491e14b-643e-43a7-979f-de9c00cfd768.png)

0101FE57与0101FE5D地址处有“向EDI所指位置写入内容”的指令。此时EDI值指向第一个节区中的地址。**也就是说，这些命令会先执行解压缩操作，然后写入实际内存。**在0101FE5E与0101FE61地址处通过CMP/JB指令继续执行循环，直到EDI值为01014B5A（[ESI+34]-01014B5A）。地址0101FE61即是解码循环的结束部分。实际上，在循环反复执行时跟踪，可以随时看到向EDI所指地址写入了什么值。

# 19.3设置IAT
**一般而言，压缩器执行完解码循环后会根据原文件重新组织IAT。**UPack也有类似过程，请看图19-9。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581408955981-b44e12b7-cd13-49da-885d-baeb172e38dd.png)

如图19-9所示，**UPack会使用导入的2个函数（LoadLibraryA与GetProcAddress)边执行循环边构建原本notepad的IAT（先获取notepad中导入函数的实际内存地址，再写入原IAT区域）**。该过程结束后，由0101FEAF地址处的RETN命令将运行转到OEP处，如图19-10所示。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581409094548-4a94f1b0-da5a-4943-8a57-8476b4ea48d8.png)

各位辛苦了。虽然分析Upack压缩的PE文件头难度比较大，但调试却相对容易得多。希望各立反复翻看这部分内容，不断调试，直到熟练掌握。

# 19.4小结
![](https://cdn.nlark.com/yuque/0/2020/png/574026/1581409171269-9e801c8f-f62f-4bb9-8944-e66887ebeede.png)

出处：UPack制作者-dwing's homepage

本章讲解了有关UPack PE文件头分析与调试的内容。除UPack外，还有许多其他压缩器，之所以花费大量的时间与精力分析UPack完全是因为我个人的学习体会（经验）。

我学完PE知识后，以为已经完全掌握了PE文件格式的相关知识，但接触UPack后才发现，原来PE还有另一片新天地。也认识到，PE规范始终只是个规范而已，实际实现会受PE装载器的开发者左右，要针对不同版本的OS实际测试才行。希望各位也能拥有与我类似的经验与感受，所以本章详细讲解了UPack。当然，所讲内容未完全涵盖PE文件头的“打补丁”操作。但是我可以自信地告诉大家：只要征服了UPack，以后不论遇到哪种变形的PE文件头都能应付自如。只要熟练掌握了PE文件头中使用了哪些值、未使用哪些值，就能轻松分析各种变形后的PE文件头（这是我的个人经验）。

