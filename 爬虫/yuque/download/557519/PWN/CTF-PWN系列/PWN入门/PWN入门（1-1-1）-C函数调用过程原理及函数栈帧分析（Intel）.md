> 文章修改自：[https://segmentfault.com/a/1190000007977460](https://segmentfault.com/a/1190000007977460)
>
> [@de8ug](undefined/de8ug)提出的疑问，现将文章中的语法改为Intel。
>
> 2021-11-14 20:18文章修改：
>
> **<font style="color:#E8323C;">原文章中使用的是AT&T汇编指令语法，但是现在最常见的是Intel的语法。为了与后续的文章进行对照，在此篇文章中将原文的语法全部更换为Intel。图片中出现的如"%ebp"都是使用的是AT&T语法，为了偷懒在本篇文章中图片就不修改了，指的是"ebp寄存器"。</font>**
>

在**<font style="color:#F5222D;">x86</font>**的计算机系统中，**<font style="color:#F5222D;">内存空间中的栈主要用于保存函数的参数，返回值，返回地址，本地变量等</font>**。一切的函数调用都要将不同的数据、地址压入或者弹出栈。因此，为了更好地理解函数的调用，我们需要先来看看栈是怎么工作的。

## 栈是什么？
简单来说，栈是一种**<font style="color:#F5222D;">LIFO（last-in,first-out）</font>**形式的数据结构，所有的数据都是后进先出。这种形式的数据结构正好满足我们调用函数的方式: 父函数调用子函数，父函数在前，子函数在后；返回时，子函数先返回，父函数后返回。**<font style="color:#F5222D;">栈支持两种基本操作，push和pop</font>**。push将数据压入栈中，pop将栈中的数据弹出并存储到指定寄存器或者内存中。

下面是一个push操作的例子。假设我们有一个栈，其中黄色部分是已经写入数据的区域，绿色部分是还未写入数据的区域。现在我们将0x50压入栈中：

```plain
push 0x50 // 将0x50的压入栈
```

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596273908791-b239c1e9-8fbe-404b-80ed-5257f4dad541.png)

我们再来看看pop操作的例子：

```plain
pop 寄存器名称   // 将栈中的0x50弹出到某个寄存器中
```

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596273991197-cefc2361-7896-4d5e-8d7e-97386a00713d.png)

这里有两点需要注意的：

第一，上面例子中**<font style="color:#F5222D;">栈的生长方向是从高地址到低地址的</font>**，对应到本文的图片中栈是向下生长的。

第二，**<font style="color:#F5222D;">pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问（但是仍然可以访问）。</font>**

有了这些栈的基本知识后，现在可以看看在x86-32bit系统下C语言函数是如何调用的了。

## 栈帧是什么？
栈帧，也就是stack frame，**<font style="color:#F5222D;">其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）</font>**。**<font style="color:#F5222D;">栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。</font>**在x86-32bit中，**<font style="color:#F5222D;">我们用 </font>**`**<font style="color:#E8323C;">ebp</font>**`**<font style="color:#F5222D;"> 指向栈底、用 </font>**`**<font style="color:#F5222D;">esp</font>**`**<font style="color:#F5222D;"> 指向栈顶</font>**。下面是一个栈帧的示意图：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596274083267-017f24ac-38ef-4813-8111-cf9cef1f9c71.png)

一般来说，我们将 `ebp` 到 `esp` 之间区域当做栈帧。**<font style="color:#F5222D;">并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。</font>**在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”。在这个过程中：

1）“调用者”需要知道在哪里获取“被调用者”返回的值；

2）“被调用者”需要知道传入的参数在哪里，

3）返回的地址在哪里。

同时，**<font style="color:#F5222D;">我们需要保证在“被调用者”返回后，</font>**`ebp`**<font style="color:#F5222D;">, </font>**`esp`**<font style="color:#F5222D;">  等寄存器的值应该和调用前一致。</font>**因此，我们需要使用栈来保存这些数据。

## 函数调用实例
### 函数的调用
我们直接通过实例来看函数是如何调用的：

```c
int MyFunction(int x, int y, int z)
{
    int a, b, c;
    a = 10;
    b = 5;
    c = 2;
    ...
    return;
}
int TestFunction()
{
    MyFunction1(1, 2, 3);
    ...
}
```

当调用这个函数时，`MyFunction()` 的汇编代码大致如下：

```plain
_MyFunction:
    push ebp            ; //保存ebp的值
    mov  ebp, esp       ; //将esp的值赋给ebp，使新的ebp指向栈顶
    sub  esp, 0x12  		; //分配额外空间给本地变量
   	mov  qword ptr [ebp-4], 10  ;  //对栈中的内存进行赋值操作
    mov  qword ptr [ebp-8], 5  ;   //对栈中的内存进行赋值操作
    mov  qword ptr [ebp-12], 2  ;  //对栈中的内存进行赋值操作
```

光看代码可能还是不太明白，我们先来看看此时的栈是什么样的：

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596274227720-b4e3c282-9f15-44cd-875d-90635d9f19d7.png)

此时_**调用者**_做了两件事情：第一，将被调用函数的参数压入栈中。第二，**<font style="color:#F5222D;">将返回地址压入栈中。这两件事都是调用者负责的，因此压入的栈应该属于调用者的栈帧</font>**。我们再来看看_**<font style="color:#000000;">被调用者</font>**_，它也做了两件事情：第一，将老的（调用者的） `ebp` 压入栈，此时 `esp` 指向它。第二，将 `esp` 的值赋给 `ebp`, `ebp` 就有了新的值，它也指向存放老 `ebp` 的栈空间。这时，它成了是函数 `MyFunction()` 栈帧的栈底。这样，我们就保存了“调用者”函数的 `ebp`，并且建立了一个新的栈帧。

只要这步弄明白了，下面的操作就好理解了。在 `ebp` 更新后，我们先分配一块0x12字节的空间用于存放本地变量，这步使用 `sub`实现。通过使用 `mov转移指令` 配合 `字节数 ptr [offset]` 我们便可以给 `a`, `b` 和 `c` 赋值了。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596274475794-6402472a-0a71-455d-9fb7-6afd586024b9.png)

### 函数的返回
上面讲的都是函数的调用过程，我们现在来看看函数是如何返回的。从下面这个例子我们可以看出，和调用函数时正好相反。当函数完成自己的任务后，它会将 `esp` 移到 `ebp` 处，然后再弹出旧的 `ebp` 的值到 `ebp寄存器`。这样`ebp` 就恢复到了函数调用前的状态了。

```c
int MyFunction( int x, int y, int z )
{
    int a, int b, int c;
    ...
    return;
}
```

其汇编大致如下：

```plain
_MyFunction:
    push ebp
    mov  ebp, esp
    ...
    mov esp, ebp
    pop ebp
    ret
```

我们注意到最后有一个 `ret` 指令，这个指令相当于 `pop + jump`。它首先将数据（返回地址）弹出栈并保存到`eip` 中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。

![](https://cdn.nlark.com/yuque/0/2020/png/574026/1596274676103-01561e7b-a4b1-445f-a77e-61a1de860b73.png)

## 总结
到这里，C函数的调用过程就基本讲完了。函数的调用其实不难，只要搞懂了如何保存以及还原 `ebp` 和 `esp`就能明白函数是如何通过栈帧进行调用和返回的了。

