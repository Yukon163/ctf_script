> 文章改动于：[https://www.anquanke.com/post/id/82713](。)
>

# 0x00 序
格式化字符串漏洞是一个很古老的漏洞了，现在几乎已经见不到这类漏洞的身影，但是作为漏洞分析的初学者来说，还是很有必要研究一下的，因为这是基础。

# 0x01 基础知识—栈
在进行真正的格式化字符串攻击之前，我们需要了解一些基础知识，方便更好的理解该类漏洞。接下来我们就一起看一下栈相关的知识:  
    说到栈我们不得不提的就是函数调用与参数传递，因为栈的作用就是动态的存储函数之间的调用关系，从而保证在被调用函数返回时能够回到母函数中继续执行。

栈其实是一种数据结构，栈中的数据是**<font style="color:#F5222D;">先进后出(First In Last Out</font>**)，常见的操作有两种:**<font style="color:#F5222D;">压栈(PUSH)和弹栈(POP)，</font>**

用于标识栈属性的也有两个:栈顶(TOP)和栈底(BASE)。

PUSH:为栈增加一个元素。

POP:从栈中取出一个元素。

TOP:标识栈顶的位置，并且是动态变化的，每进行一次push操作，它会自增1，反之，每进行一次pop操作，它会自减1

BASE:标识栈底位置，它的位置是不会变动的。

函数调用时到底发生了什么呢，我们将通过下面的代码做一下简单的认识。 示例代码:

```c
int func_B(arg_B1,arg_B2)
{
       int var_B;
       var_B = arg_B1+arg_B2;
       return var_B;
}
int func_A(arg_A1,arg_A2)
{
     int var_A;
     var_A = func_B(arg_A1,arg_A2);
     return var_A; 
}
int main (int argc, char **argv, char **envp)
{
    int var_main;
    var_main=func_A(1,2);
    return var_main;
}
```

程序的执行过程如下图所示:

![](https://cdn.nlark.com/yuque/0/2020/jpeg/574026/1597464094020-e7edd0c0-657b-4c2f-b91b-930bc4484e26.jpeg)

通过上图我们可以看到程序执行的流程:main–func_A–func_B–func_A–main

CPU在执行程序时是如何知道各个函数之间的调用关系呢，接下来我们将介绍一个新的名词:栈帧。**<font style="color:#F5222D;">当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，这个栈帧中的内存空间被它所属的函数独占，当函数返回时，系统栈会弹出该函数所对应的栈帧。32位系统下提供了两个特殊的寄存器(ESP和EBP)识栈帧。</font>**

    - **ESP**:栈指针寄存器，存放一个指针，该指针指向**栈顶**。
    - **EBP**:基址指针寄存器，存放一个指针，该指针指向**栈底**。

CPU**<font style="color:#F5222D;">利用EBP(不是ESP)</font>**寄存器来访问栈内局部变量、参数、函数返回地址，程序运行过程中，ESP寄存器的值随时变化，如果以ESP的值为基准对栈内的局部变量、参数、返回地址进行访问显然是不可能的**<font style="color:#F5222D;">，所以在进行函数调用时，先把用作基准的ESP的值保存到EBP，这样以后无论ESP如何变化，都能够以EBP为基准访问到局部变量、参数以及返回地址。</font>**接下来将编译上述代码并进行调试，从而进一步了解函数调用以及参数传递的过程。

首先用gcc进行编译:gcc -fno-stack-protector -o 1 1。c，用objdump进行反汇编查看:objdump -d 1

```plain
		 0804841d <main>:
     804841d:   55                      push   %ebp             ;函数开始(保存旧栈帧的底部)
     804841e:   89 e5                   mov    %esp,%ebp        ;设置新栈帧底部(切换栈帧)
     8048420:   83 ec 10                sub    $0x10,%esp       ;设置新栈帧的顶部(抬高栈顶,为新栈帧开辟空间)
     8048423:   6a 02                   push   $0x2             ;参数入栈(从右往左)
     8048425:   6a 01                   push   $0x1
     8048427:   e8 d5 ff ff ff          call   8048401 <func_A> ;向栈中压入当前指令所在的内存地址,保存返回地址
                                                                ;跳转到所调用函数的入口处执行
     804842c:   83 c4 08                add    $0x8,%esp
     804842f:   89 45 fc                mov    %eax,-0x4(%ebp)
     8048432:   8b 45 fc                mov    -0x4(%ebp),%eax
     8048435:   c9                      leave  
     8048436:   c3                      ret 
     08048401 <func_A>:
     8048401:   55                      push   %ebp
     8048402:   89 e5                   mov    %esp,%ebp
     8048404:   83 ec 10                sub    $0x10,%esp
     8048407:   ff 75 0c                pushl  0xc(%ebp)
     804840a:   ff 75 08                pushl  0x8(%ebp)
     804840d:   e8 d9 ff ff ff          call   80483eb <func_B>
     8048412:   83 c4 08                add    $0x8,%esp
     8048415:   89 45 fc                mov    %eax,-0x4(%ebp)
     8048418:   8b 45 fc                mov    -0x4(%ebp),%eax
     804841b:   c9                      leave  
     804841c:   c3                      ret
```

func_A栈帧如下图所示:

![](https://cdn.nlark.com/yuque/0/2020/jpeg/574026/1597464093971-89061186-729f-4bf8-9f83-cdd6a32111f1.jpeg)

我们将通过以下图例对本次函数调用做一个总结:

![](https://cdn.nlark.com/yuque/0/2020/jpeg/574026/1597464094107-a9fa214c-fd66-41d2-b46c-b9d858c14582.jpeg)

通过前面的函数调用细节以及栈中数据的分布情况，**<font style="color:#F5222D;">我们可以发现局部变量是在栈中挨个排放的，如果这些局部变量中有数组之类的缓冲区，并且程序存在数组越界的问题，那么越界的数组元素就有可能破坏栈中相邻变量的值，进而破坏EBP的值、返回地址等重要数据。</font>**

因为本次主要讨论的是格式化字符串漏洞，关于栈溢出的细节就不做讨论了，感兴趣的可以查阅相关资料。

有了以上的基础知识以后，我们就可以进一步分析格式化字符串漏洞了。

