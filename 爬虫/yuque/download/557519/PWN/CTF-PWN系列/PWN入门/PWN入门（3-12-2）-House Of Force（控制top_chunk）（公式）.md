> 附件：
>
> 链接: [https://pan.baidu.com/s/1AR1i1CxwcgN9kbwwYPfWzw](https://pan.baidu.com/s/1AR1i1CxwcgN9kbwwYPfWzw)  密码: u1dq
>
> --来自百度网盘超级会员V3的分享
>

这一小节介绍HOF中的两个小公式。

# 向后控制内存--公式解释
我们还是用上一小节中的向后控制内存--Demo3。

当我们篡改top_chunk_size为0xffffffffffffffff之后，内存如下所示：

```c
pwndbg> x/16gx 0x602000
0x602000:   0x0000000000000000  0x0000000000000021 chunk1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0xffffffffffffffff #old_top_chunk
                                #ptr
0x602030:   0x0000000000000000  0x0000000000000000
......
0x602070:   0x0000000000000000  0x0000000000000000
pwndbg> 
```

将这时的top_chunk称之为old_top_chunk。

然后malloc(140737345551056)[malloc(0x7ffff77cfad0)]之后：

```c
pwndbg> x/16gx 0x7ffff7dd1b00
0x7ffff7dd1b00 <__memalign_hook>:   0x00007ffff7a92ea0  0xffff800008830519 #new_top_chunk
0x7ffff7dd1b10 <__malloc_hook>: 0x0000000000000000  0x0000000000000000
                                #要控制的地址
0x7ffff7dd1b20 <main_arena>:    0x0000000100000000  0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>: 0x0000000000000000  0x00007ffff7dd1b00
pwndbg> 
```

我们将此时的top_chunk称之为new_top_chunk。之后malloc(0x10)之后就会控制__malloc_hook地址：

```c
pwndbg> x/20gx 0x7ffff7dd1b00
0x7ffff7dd1b00 <__memalign_hook>:   0x00007ffff7a92ea0  0x0000000000000021#new_chunk(原top_chunk)
0x7ffff7dd1b10 <__malloc_hook>: 0x0000000000000000  0x0000000000000000
                                #要控制的地址
0x7ffff7dd1b20 <main_arena>:    0x0000000100000000  0xffff8000088304f9 #new_new_top_chunk
0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000  0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>: 0x0000000000000000  0x00007ffff7dd1b20
0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000  0x00007ffff7dd1b78
0x7ffff7dd1b90 <main_arena+112>:    0x00007ffff7dd1b78  0x00007ffff7dd1b88
pwndbg> 
```

将此时的top_chunk称之为new_new_top_chunk。

看一下文章中是怎么算得：0x7ffff7dd1b00-0x602020-**0x10**=140737345551056=0x7ffff77cfad0

“140737345551056”这个值也就是第一次malloc的空间。

首先，地址0x7ffff7dd1b00是new_top_chunk起始地址；0x602020是old_top_chunk的起始地址，两个数值相减是他们之间的内存“距离”。

为了方便理解接下来的讲解，我们简单的举一个例子：

```c
#include<stdio.h>
int main(){
	malloc(0x0);
	malloc(0x10);
	malloc(0x20);
	malloc(0x30);
	malloc(0x40);
	malloc(0x50);
	malloc(0x60);
	malloc(0x70);
	malloc(0x80);
	malloc(0x90);
	malloc(0xa0);
	malloc(0xb0);
	malloc(0xc0);
	malloc(0xd0);
	malloc(0xe0);
	return 0;
}
```

> 编译命令：gcc -g test1.c -o test1
>

编译完成之后，进行gdb调试，对代码的第18行下断点，对堆内存进行查看：

```c
pwndbg> x/280gx 0x602000
0x602000:	0x0000000000000000	0x0000000000000021 malloc(0x0)后top_chunk下移2行
0x602010:	0x0000000000000000	0x0000000000000000
0x602020:	0x0000000000000000	0x0000000000000021 malloc(0x10)后top_chunk下移2行
0x602030:	0x0000000000000000	0x0000000000000000
0x602040:	0x0000000000000000	0x0000000000000031 malloc(0x20)后top_chunk下移3行
0x602050:	0x0000000000000000	0x0000000000000000
0x602060:	0x0000000000000000	0x0000000000000000
0x602070:	0x0000000000000000	0x0000000000000041 malloc(0x30)后top_chunk下移4行
0x602080:	0x0000000000000000	0x0000000000000000
0x602090:	0x0000000000000000	0x0000000000000000
0x6020a0:	0x0000000000000000	0x0000000000000000
0x6020b0:	0x0000000000000000	0x0000000000000051 malloc(0x40)后top_chunk下移5行
0x6020c0:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x6020f0:	0x0000000000000000	0x0000000000000000
0x602100:	0x0000000000000000	0x0000000000000061 malloc(0x50)后top_chunk下移6行
0x602110:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602150:	0x0000000000000000	0x0000000000000000
0x602160:	0x0000000000000000	0x0000000000000071 malloc(0x60)后top_chunk下移7行
0x602170:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x6021c0:	0x0000000000000000	0x0000000000000000
0x6021d0:	0x0000000000000000	0x0000000000000081 malloc(0x70)后top_chunk下移8行
0x6021e0:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602240:	0x0000000000000000	0x0000000000000000
0x602250:	0x0000000000000000	0x0000000000000091 malloc(0x80)后top_chunk下移9行
0x602260:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x6022d0:	0x0000000000000000	0x0000000000000000
0x6022e0:	0x0000000000000000	0x00000000000000a1 malloc(0x90)后top_chunk下移a行
0x6022f0:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602370:	0x0000000000000000	0x0000000000000000
0x602380:	0x0000000000000000	0x00000000000000b1 malloc(0xa0)后top_chunk下移b行
0x602390:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602420:	0x0000000000000000	0x0000000000000000
0x602430:	0x0000000000000000	0x00000000000000c1 malloc(0xb0)后top_chunk下移c行
0x602440:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x6024e0:	0x0000000000000000	0x0000000000000000
0x6024f0:	0x0000000000000000	0x00000000000000d1 malloc(0xc0)后top_chunk下移d行
0x602500:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x6025b0:	0x0000000000000000	0x0000000000000000
0x6025c0:	0x0000000000000000	0x00000000000000e1 malloc(0xd0)后top_chunk下移e行
0x6025d0:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602690:	0x0000000000000000	0x0000000000000000
0x6026a0:	0x0000000000000000	0x00000000000000f1 malloc(0xe0)后top_chunk下移f行
0x6026b0:	0x0000000000000000	0x0000000000000000
......（省略内容均为空）
0x602780:	0x0000000000000000	0x0000000000000000
0x602790:	0x0000000000000000	0x0000000000020871 #top_chunk
......（省略内容均为空）
0x6028b0:	0x0000000000000000	0x0000000000000000
pwndbg> 
```

从上面可以得出一个结论，当malloc的大小为0x10的整数倍时，malloc(0x?0)会使top_chunk下移（?+1）行，且new_top_chunk的地址-old_top_chunk的地址=0x(?+1)0。

回到之前的式子：0x7ffff7dd1b00-0x602020-**0x10**=140737345551056=0x7ffff77cfad0

套用一下之前的结论：

0x7ffff7dd1b00(new_top_chunk)-0x602020(old_top_chunk)=0x7ffff77cfae0（=0x(?+1)0），因此malloc的大小为：0x7ffff77cfae0-0x10=0x7ffff77cfad0(0x?0)，即malloc(0x7ffff77cfad0)。

因此要控制高地址，公式为：

**<font style="color:#F5222D;">malloc_size(malloc(size))=new_top_chunk-old_top_chunk-0x10</font>**

**<font style="color:#F5222D;">0x10实际上减去的是 chunk 头大小(32位是0x8，64位是0x10)。</font>**

# 向前控制内存--公式解释
这里我们使用上一小节中的Demo2进行说明：

现在top_chunk_size已经被控制为0xffffffffffffffff

```c
pwndbg> x/16gx 0x602000
0x602000:   0x0000000000000000  0x0000000000000021 #chunk1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0xffffffffffffffff #old_top_chunk
                                #ptr
0x602030:   0x0000000000000000  0x0000000000000000
0x602040:   0x0000000000000000  0x0000000000000000
0x602050:   0x0000000000000000  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000000000
0x602070:   0x0000000000000000  0x0000000000000000
pwndbg> 
```

现在，要控制的内存地址为：0x601020

```c
pwndbg> x/16gx 0x601000
0x601000:   0x0000000000600e28  0x00007ffff7ffe168
0x601010:   0x00007ffff7deef10  0x0000000000001009
0x601020:   0x00007ffff7a91180  0x0000000000000000
            #malloc@got.plt
0x601030:   0x0000000000000000  0x0000000000000000
0x601040:   0x0000000000000000  0x0000000000000000
0x601050:   0x0000000000000000  0x0000000000000000
0x601060:   0x0000000000000000  0x0000000000000000
0x601070:   0x0000000000000000  0x0000000000000000
pwndbg>
```

假如说我们最后使用malloc(0x10)来控制malloc@got.plt，那么在malloc(0x10)之前，堆内存地址应该是这样的：

```c
pwndbg> x/16gx 0x601000
0x601000:   0x0000000000600e28  0x00007ffff7ffe168 
0x601010:   0x00007ffff7deef10  0x0000000000001009 #new_top_chunk
0x601020:   0x00007ffff7a91180  0x0000000000000000
            #malloc@got.plt
0x601030:   0x0000000000000000  0x0000000000000000
0x601040:   0x0000000000000000  0x0000000000000000
0x601050:   0x0000000000000000  0x0000000000000000
0x601060:   0x0000000000000000  0x0000000000000000
0x601070:   0x0000000000000000  0x0000000000000000
pwndbg>
```

两个top_chunk的地址相差：

new_top_chunk_addr-old_top_chunk_addr=0x601010-0x602020=-0x1010=-4412

再根据前面的经验，减去0x10的chunk_header大小即可：malloc(-0x1020)=malloc(-4128)

这个malloc大小和之前的（malloc(-4120); ）并不冲突，因为我们输入的要malloc大小如果不合适的话会在申请空间时自动对齐，导致malloc出的chunk_size相同，自动对齐这个东西之后再说。

> 我在附件里会上传里修改后的代码，我调试过是没有问题的。
>

# 总结
**<font style="color:#F5222D;">公式为：malloc(size)中的size=</font>****<font style="color:#F5222D;">new_top_chunk_addr-old_top_chunk_addr-0x10</font>**

+ **<font style="color:#F5222D;">new_top_chunk_addr为要转移top_chunk的目标地址。</font>**
+ **<font style="color:#F5222D;">old_top_chunk_addr为已经被篡改的top_chunk地址。</font>**

